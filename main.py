import pygame
import sys
import numpy as np
import os # 新增
from dsp_engine import DSPEngine as dsp
from levels import LevelManager

# --- 初始化 ---
pygame.init()
pygame.mixer.init() # 初始化音频混合器
WINDOW_WIDTH = 1600 # 拉宽，原为 1440
WINDOW_HEIGHT = 900 # 拉高，原为 800
HUD_WIDTH = 450 # 稍微增加 HUD 宽度，原为 420
MAP_WIDTH = WINDOW_WIDTH - HUD_WIDTH

screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("The Great Silence - 大静默")
clock = pygame.time.Clock()

# --- 颜色定义 ---
BG_COLOR = (10, 12, 16)
PANEL_COLOR = (20, 24, 30)
MAP_BG_COLOR = (15, 18, 22)
ACCENT_COLOR = (0, 180, 255)
SUCCESS_COLOR = (50, 200, 100)
ERROR_COLOR = (230, 80, 80)
TEXT_COLOR = (220, 220, 220)

# --- 字体设置 ---
def get_font_name():
    # Attempt to load system font path directly
    preferred_fonts = ['Microsoft YaHei', 'SimHei', 'SimSun', 'Arial Unicode MS']
    for f in preferred_fonts:
        try:
            if pygame.font.match_font(f):
                return f
        except:
            continue
    return None 

# Initialize font module before calling SysFont
pygame.font.init()
FONT_NAME = get_font_name()

def get_resource_path(relative_path):
    """获取资源绝对路径，兼容 PyInstaller"""
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)

def load_safe_font(font_name, size):
    """尝试加载中文字体，优先使用本地文件，否则尝试系统字体"""
    # 1. 优先尝试本地下载的字体 (wqy-microhei.ttc)
    local_font_path = get_resource_path(os.path.join("fonts", "wqy-microhei.ttc"))
    if os.path.exists(local_font_path):
        try:
            return pygame.font.Font(local_font_path, int(size))
        except Exception:
            pass
            
    # 2. 尝试备用本地字体 (兼容旧版或其他字体)
    local_font_path_alt = get_resource_path(os.path.join("fonts", "SourceHanSansCN-Regular.otf"))
    if os.path.exists(local_font_path_alt):
        try:
            return pygame.font.Font(local_font_path_alt, int(size))
        except Exception:
            pass

    # 3. 尝试系统字体
    try:
        if font_name is not None:
            return pygame.font.SysFont(font_name, size)
    except Exception:
        pass
    
    # 4. 最后的保底：使用 Pygame 默认内置字体
    return pygame.font.Font(None, int(size * 1.2))

# 使用安全加载函数
font = load_safe_font(FONT_NAME, 20)
header_font = load_safe_font(FONT_NAME, 32)
label_font = load_safe_font(FONT_NAME, 16)

STATE_START_SCREEN = 0
STATE_PLAYING = 1
STATE_BRIEFING = 2
STATE_TECH_UNLOCK = 3
STATE_EDU_SHOWCASE = 4
STATE_KNOWLEDGE_MENU = 5
STATE_KNOWLEDGE_DETAIL = 6 
STATE_CREDITS = 7  # 新增通关版权状态
STATE_CONCLUSION = 8 # 新增结论状态
STATE_SETTINGS = 9 # 新增设置状态
STATE_LETTER_VIEW = 10 # 新增信件展示状态
STATE_INTRO_1 = 11 # 新增开场 1: HOPE IS A WAVEFORM
STATE_INTRO_2 = 12 # 新增开场 2: IS ANYONE OUT THERE?

# --- 音乐管理 ---
current_bgm = None
def play_bgm(music_name):
    global current_bgm
    if current_bgm == music_name:
        return
    
    # 如果 music_name 为 None，停止播放
    if music_name is None:
        pygame.mixer.music.stop()
        current_bgm = None
        return
    
    # 使用 resource_path 确保在不同目录下运行时路径依然正确
    rel_path = f"music/{music_name}"
    path = resource_path(rel_path)
    try:
        pygame.mixer.music.load(path)
        pygame.mixer.music.play(-1, fade_ms=2000) # 循环播放，2秒淡入
        current_bgm = music_name
    except Exception as e:
        print(f"无法加载音乐 {path}: {e}")

def get_level_music(level_id):
    # 根据用户要求的逻辑映射音乐
    if level_id in [1, 2, 3]: return "ofeliasdream.mp3"
    if level_id in [4, 5]: return "deepblue.mp3"
    if level_id in [6, 7]: return "fatalechoes.mp3"
    if level_id == 8: return "newdawn.mp3"
    if level_id in [9, 10]: return "dawnofchange.mp3"
    return "ofeliasdream.mp3"

current_state = STATE_START_SCREEN
previous_state = STATE_START_SCREEN # Default
level_mgr = LevelManager()
g_tech_unlock_level = None
g_conclusion_level = None # 存储结论画面关卡信息
g_original_level = None # 用于存储进入隐藏关前的原始关卡数据
g_hidden_level_visited = False # 追踪是否已访问隐藏关
g_letter_scroll_idx = 0 # 信件打字机效果索引
g_edu_slides = [] # Store current slides
g_edu_slide_idx = 0
g_knowledge_list = [] # Cached list of knowledge items
g_current_knowledge_item = None
g_intro_alpha = 0 # 介绍画面透明度
g_intro_timer = 0 # 介绍画面计时器

# --- 绘图工具 ---
credits_scroll_y = WINDOW_HEIGHT
CREDITS_TEXT = [
    "THE GREAT SILENCE",
    "大静默",
    "",
    "--- 任务完成 ---",
    "全球通信骨干网已成功修复",
    "大静默时代正式终结",
    "",
    "--- 制作团队 ---",
    "首席工程师: 用户",
    "数字化视觉: Pygame Framework",
    "信号处理引擎: NumPy & DSP Engine",
    "",
    "--- 背景音乐 ---",
    "Ofelia's Dream",
    "Deep Blue",
    "Fatal Echoes",
    "New Dawn",
    "Dawn of Change",
    "",
    "--- Music Source: Bensound.com ---",
    "Artist: FoePound",
    "License code: 3JBSWMCTGE7VRABZ",
    "",
    "Artist: Benjamin Tissot",
    "License code: QKNESAYELWLZGLW4",
    "License code: GDYDTYEL5JY5DKP7",
    "License code: 8PG0HEZ5K3ZHKI55",
    "",
    "Artist: Roman Senyk",
    "License code: J4GDMPQCWKNIYXU9",
    "",
    "感谢所有在实验室并肩作战的工程师们",
    "",
    "点击任意位置返回主菜单"
]

def draw_credits_screen(surface):
    global credits_scroll_y
    surface.fill(BG_COLOR)
    
    # 绘制静态背景装饰
    for i in range(100):
        # 伪随机但固定的星星（简单处理）
        x = (i * 137) % WINDOW_WIDTH
        y = (i * 263) % WINDOW_HEIGHT
        pygame.draw.circle(surface, (40, 50, 60), (x, y), 1)
         
    curr_y = credits_scroll_y
    for line in CREDITS_TEXT:
        if not line:
            curr_y += 20
            continue
        if line.startswith("---"):
            color = ACCENT_COLOR
            f = header_font
        elif line == "SIGNAL FLOW PROTOCOL":
            color = SUCCESS_COLOR
            f = header_font
        else:
            color = TEXT_COLOR
            f = font
            
        txt = f.render(line, True, color)
        surface.blit(txt, (WINDOW_WIDTH // 2 - txt.get_width() // 2, curr_y))
        curr_y += 45
    
    credits_scroll_y -= 1 # 滚动
    if credits_scroll_y < -len(CREDITS_TEXT) * 45 - 100:
        credits_scroll_y = WINDOW_HEIGHT # 循环滚动

def draw_bezier_curve(surface, color, p0, p1, p2, segments=20, width=2):
    points = []
    for t in np.linspace(0, 1, segments):
        x = (1-t)**2 * p0[0] + 2*(1-t)*t * p1[0] + t**2 * p2[0]
        y = (1-t)**2 * p0[1] + 2*(1-t)*t * p1[1] + t**2 * p2[1]
        points.append((x, y))
    pygame.draw.lines(surface, color, False, points, width)

def get_bezier_point(t, p0, p1, p2):
    x = (1-t)**2 * p0[0] + 2*(1-t)*t * p1[0] + t**2 * p2[0]
    y = (1-t)**2 * p0[1] + 2*(1-t)*t * p1[1] + t**2 * p2[1]
    return (x, y)

def draw_map_connection(surface, p0, p1, p2, progress=0.0, active=False):
    draw_bezier_curve(surface, (40, 50, 60), p0, p1, p2, segments=40, width=2)
    if active:
        curr_pos = get_bezier_point(progress, p0, p1, p2)
        pygame.draw.circle(surface, ACCENT_COLOR, (int(curr_pos[0]), int(curr_pos[1])), 6)
        partial_points = []
        for t in np.linspace(0, progress, int(20 * progress) + 2):
            partial_points.append(get_bezier_point(t, p0, p1, p2))
        if len(partial_points) > 1:
            pygame.draw.lines(surface, ACCENT_COLOR, False, partial_points, 3)

def draw_node(surface, pos, name, is_dest=False):
    color = (255, 100, 100) if is_dest else (100, 255, 100)
    pygame.draw.circle(surface, color, pos, 6)
    text = font.render(name, True, (200, 200, 200))
    rect = text.get_rect(center=(pos[0], pos[1] + 20))
    pygame.draw.rect(surface, (0,0,0,150), rect.inflate(10,4), border_radius=3)
    surface.blit(text, rect)

def render_text_wrapped(surface, text, pos, max_width, font, color=(200, 200, 200), align='left', draw=True):
    """Renders text and wraps it to a certain width. Returns the final Y position."""
    lines = []
    paragraphs = text.split('\n')
    for paragraph in paragraphs:
        if not paragraph:
            lines.append("")
            continue
            
        current_line = ""
        i = 0
        while i < len(paragraph):
            char = paragraph[i]
            if ord(char) > 0x2E80: 
                unit = char
                i += 1
            else:
                unit = ""
                while i < len(paragraph) and ord(paragraph[i]) <= 0x2E80:
                    unit += paragraph[i]
                    if paragraph[i] == ' ':
                        i += 1
                        break
                    i += 1
            
            test_line = current_line + unit
            w, _ = font.size(test_line)
            if w <= max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = unit
                
        if current_line:
            lines.append(current_line)
    
    x_start, y = pos
    line_h = font.get_linesize()
    for line in lines:
        if line and draw:
            line_surf = font.render(line.strip(), True, color)
            lw, lh = line_surf.get_size()
            draw_x = x_start - lw // 2 if align == 'center' else x_start
            surface.blit(line_surf, (draw_x, y))
        y += line_h
    return y # Return the next Y position

# 用于绘制星座图残影的 Surface
constellation_surface = None

def draw_constellation(surface, symbols, cx, cy, scale=60):
    global constellation_surface
    
    # 区域大小
    width, height = 260, 200
    
    # 初始化或重新创建 Surface (如果大小匹配不上)
    if constellation_surface is None:
        constellation_surface = pygame.Surface((width, height), pygame.SRCALPHA)
        # 初始全黑背景 (改为完全透明，让背景色通过，或者保持半透明黑)
        constellation_surface.fill((0, 0, 0, 0)) 

    # 1. 实现余辉残影 + 电子云效果:
    # 相比之前简单的 fade，这里我们用更强一点的 fade 来保证旧点不要留太久变成线条，
    # 而是形成一种"区域感"。
    fade_surface = pygame.Surface((width, height), pygame.SRCALPHA)
    # Alpha 值决定了残影的长度。值越小，残影越长。
    # 为了电子云效果，我们需要比较长的残影，所以 Alpha 小一点 (清除得慢)
    fade_surface.fill((15, 18, 22, 20)) 
    constellation_surface.blit(fade_surface, (0, 0))

    # 在 Surface 内部的中心坐标
    scx, scy = width // 2, height // 2

    # 绘制坐标轴 (每一帧稍微重绘一下以保持清晰，或者只画一次)
    # 为了保持残影效果，坐标轴也应该在 fade 之后重绘
    pygame.draw.line(constellation_surface, (60, 70, 80), (scx - 100, scy), (scx + 100, scy), 1)
    pygame.draw.line(constellation_surface, (60, 70, 80), (scx, scy - 100), (scx, scy + 100), 1)
    
    max_dots = 400
    step = max(1, len(symbols) // max_dots)
    
    # 辉光纹理 (预计算，提升性能)
    # 这是一个中心亮、边缘淡的圆
    if not hasattr(draw_constellation, "glow_surf"):
        # 增大光晕半径，制造朦胧感
        glow_radius = 8
        draw_constellation.glow_surf = pygame.Surface((glow_radius*2, glow_radius*2), pygame.SRCALPHA)
        
        # 外圈辉光 (低Alpha，青色/Cyan) -> 对应参考图的边缘色
        # 参考图风格: 核心白，边缘青
        pygame.draw.circle(draw_constellation.glow_surf, (0, 255, 255, 30), (glow_radius, glow_radius), glow_radius)
        pygame.draw.circle(draw_constellation.glow_surf, (0, 200, 255, 60), (glow_radius, glow_radius), glow_radius - 2)
        
        # 内圈核心 (高Alpha，白色)
        pygame.draw.circle(draw_constellation.glow_surf, (255, 255, 255, 200), (glow_radius, glow_radius), 3)
    
    for s in symbols[::step]:
        # 映射到 Surface 坐标系
        x = scx + np.real(s) * scale
        y = scy - np.imag(s) * scale
        
        # 简单的边界检查
        if 0 < x < width and 0 < y < height:
            # 2. 绘制带辉光的点
            # 使用 BLEND_ADD 模式可以让重叠的点变得更亮，模拟光的叠加
            # 稍微加一点随机抖动来模拟电子云的不确定性 (可选)
            constellation_surface.blit(draw_constellation.glow_surf, 
                                     (int(x) - 8, int(y) - 8), 
                                     special_flags=pygame.BLEND_ADD)

    # 最后将这个带有残影和辉光的 Surface 绘制到主屏幕上对应的位置
    # 目标位置的左上角
    dest_x = cx - scx
    dest_y = cy - scy
    
    # 画边框
    pygame.draw.rect(surface, (60, 70, 80), (dest_x-1, dest_y-1, width+2, height+2), 1)
    surface.blit(constellation_surface, (dest_x, dest_y))

# --- Button ---
class Button:
    def __init__(self, x, y, w, h, text, callback=None, color=(60, 60, 70), hover_color=(80, 80, 90)):
        self.rect = pygame.Rect(x, y, w, h)
        self.text = text
        self.callback = callback
        self.base_color = color
        self.hover_color = hover_color
        self.is_hovered = False

    def draw(self, surface):
        c = self.hover_color if self.is_hovered else self.base_color
        pygame.draw.rect(surface, c, self.rect, border_radius=5)
        pygame.draw.rect(surface, (255, 255, 255), self.rect, 1, border_radius=5)
        txt = font.render(self.text, True, (255, 255, 255))
        txt_rect = txt.get_rect(center=self.rect.center)
        surface.blit(txt, txt_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered and event.button == 1 and self.callback:
                self.callback()

class Slider:
    def __init__(self, x, y, w, h, min_val, max_val, initial_val):
        self.rect = pygame.Rect(x, y, w, h)
        self.min_val = min_val
        self.max_val = max_val
        self.val = max(min_val, min(initial_val, max_val))
        self.dragging = False

    def draw(self, surface):
        # Draw track
        pygame.draw.rect(surface, (40, 50, 60), self.rect, border_radius=5)
        pygame.draw.rect(surface, (100, 120, 140), self.rect, 1, border_radius=5)
        
        # Calculate handle position
        pct = (self.val - self.min_val) / (self.max_val - self.min_val)
        handle_x = self.rect.x + pct * (self.rect.width - 20)
        handle_rect = pygame.Rect(handle_x, self.rect.y, 20, self.rect.height)
        
        # Draw handle
        color = (0, 180, 255) if self.dragging else (150, 200, 220)
        pygame.draw.rect(surface, color, handle_rect, border_radius=4)

    def handle_event(self, event):
        changed = False
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                self.dragging = True
                self.update_val(event.pos[0])
                changed = True
        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1:
                self.dragging = False
        elif event.type == pygame.MOUSEMOTION:
            if self.dragging:
                self.update_val(event.pos[0])
                changed = True
        return changed

    def update_val(self, mouse_x):
        rel_x = mouse_x - self.rect.x - 10 # Offset for handle center
        pct = max(0, min(1, rel_x / (self.rect.width - 20)))
        self.val = self.min_val + pct * (self.max_val - self.min_val)


# --- Visual Effects Classes ---
class Starfield:
    def __init__(self, count=200):
        self.stars = []
        for _ in range(count):
            self.stars.append({
                'x': np.random.randint(0, MAP_WIDTH),
                'y': np.random.randint(80, WINDOW_HEIGHT),
                'speed': np.random.uniform(0.05, 0.3),
                'size': np.random.choice([1, 1, 1, 2]),
                'alpha': np.random.randint(100, 255)
            })
    
    def update(self):
        for s in self.stars:
            s['x'] -= s['speed']
            if s['x'] < 0:
                s['x'] = MAP_WIDTH
                s['y'] = np.random.randint(80, WINDOW_HEIGHT)
    
    def draw(self, surface):
        for s in self.stars:
            # Simple stars
            pygame.draw.circle(surface, (s['alpha'], s['alpha'], s['alpha']), (int(s['x']), int(s['y'])), s['size'])

class EarthBackground:
    def __init__(self):
        self.angle = 0
        
    def draw(self, surface, center_pos=(200, 800), radius=500):
        # 绘制地球的大气层光晕（外发光）
        # 通过绘制多个同心圆，透明度递减来模拟
        for i in range(20):
            alpha = int(30 * (1 - i/20.0))
            if alpha <= 0: continue
            pygame.draw.circle(surface, (0, 100, 200, alpha), center_pos, radius + i*2, 2)
            
        # 绘制地球本体边缘（简单的反锯齿圆弧效果不够好，直接画大圆）
        # 这是一个巨大的暗色圆球
        pygame.draw.circle(surface, (5, 8, 12), center_pos, radius)
        pygame.draw.circle(surface, (20, 40, 60), center_pos, radius, 2)
        
        # 经纬线装饰 (简单的视觉效果)
        # 用椭圆模拟经线
        clip_rect = pygame.Rect(center_pos[0]-radius, center_pos[1]-radius, radius*2, radius*2)
        surface.set_clip(clip_rect) # 限制绘制区域在地球圆内
        
        for i in range(0, radius, 80):
             target_rect = pygame.Rect(center_pos[0] - i, center_pos[1] - radius, i*2, radius*2)
             pygame.draw.ellipse(surface, (30, 50, 70), target_rect, 1)
        
        # 恢复剪裁
        surface.set_clip(None)

class RadarPing:
    def __init__(self):
        self.pings = [] # list of [x, y, radius, alpha]
    
    def add(self, x, y):
        # 偶尔添加一个新的波纹
        if np.random.random() < 0.02: 
            self.pings.append([x, y, 0, 255])
            
    def update(self):
        for p in self.pings:
            p[2] += 1.5 # 半径增加
            p[3] -= 3   # 透明度减少
        self.pings = [p for p in self.pings if p[3] > 0]
        
    def draw(self, surface):
        for p in self.pings:
            # 绘制扩散的波纹圆环
            # 颜色采用青色/雷达色
            color = (0, 200, 255, int(p[3]))
            # 必须画在一个支持 alpha 的 surface 上或者直接用 circle (Pygame circle 不支持 alpha fill, 但支持 alpha line 如果 surface 是 alpha 的)
            # 这里为了简单，如果主 surface 不支持 alpha，效果可能打折，但主循环一般是 RGB。
            # 更好的做法是画到一个临时层
            target_surf = pygame.Surface((int(p[2]*2 + 4), int(p[2]*2 + 4)), pygame.SRCALPHA)
            pygame.draw.circle(target_surf, color, (int(p[2]+2), int(p[2]+2)), int(p[2]), 1)
            surface.blit(target_surf, (p[0] - p[2] - 2, p[1] - p[2] - 2), special_flags=pygame.BLEND_ADD)

class DynamicGrid:
    def __init__(self):
        self.offset_x = 0
        self.offset_y = 0
        self.time = 0
        
    def update(self):
        self.time += 0.02
        # Simulate slow drift
        self.offset_x = (self.offset_x + 0.1) % 50
        
    def draw(self, surface):
        # Draw vertical lines
        for x in range(0, MAP_WIDTH + 50, 50):
            draw_x = x - self.offset_x
            
            # Simple line for now
            alpha = 20 + 5 * np.sin(draw_x*0.01 + self.time)
            color = (25, 30 + int(alpha), 40 + int(alpha))
            
            start_pos = (draw_x, 80)
            end_pos = (draw_x, WINDOW_HEIGHT)
            pygame.draw.line(surface, color, start_pos, end_pos, 1)

        # Draw horizontal lines
        for y in range(80, WINDOW_HEIGHT, 50):
            # Breathing effect on color
            alpha = 30 + 10 * np.sin(y*0.02 + self.time)
            color = (25, int(alpha), 40)
            pygame.draw.line(surface, color, (0, y), (MAP_WIDTH, y), 1)

def generate_asteroid_polygon(radius):
    num_points = np.random.randint(5, 9)
    points = []
    for i in range(num_points):
        angle = (2 * np.pi / num_points) * i
        r = radius * (0.7 + 0.3 * np.random.rand()) # Variance in radius
        points.append((r * np.cos(angle), r * np.sin(angle)))
    return points

# Global VFX instances
vfx_stars = Starfield()

vfx_earth = EarthBackground()
vfx_radar = RadarPing()
vfx_grid = DynamicGrid()

import os
import sys

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.dirname(os.path.abspath(__file__))

    return os.path.join(base_path, relative_path)

def draw_image_fit(surface, img_path, center_pos, max_size):
    
    # Use resource_path to find the file
    full_path = resource_path(img_path)
    
    if not os.path.exists(full_path): 
        # print(f"Image not found: {full_path}")
        return

    try:
        img = pygame.image.load(full_path).convert_alpha()
        # Scale to fit max_size (w, h) keeping aspect ratio
        iw, ih = img.get_size()
        mw, mh = max_size
        scale = min(mw/iw, mh/ih)
        if scale < 1.0 or scale > 1.0: # Always scale to fit box nicely
             new_size = (int(iw*scale), int(ih*scale))
             img = pygame.transform.smoothscale(img, new_size)
        
        rect = img.get_rect(center=center_pos)
        surface.blit(img, rect)
        
        # Draw border
        pygame.draw.rect(surface, (100, 150, 200), rect, 1)
        
        # Draw Label (Filename as caption?)
        # caption = os.path.splitext(os.path.basename(img_path))[0]
        # cap_surf = label_font.render(caption, True, (150,150,150))
        # surface.blit(cap_surf, (rect.centerx - cap_surf.get_width()//2, rect.bottom + 5))
        
    except Exception as e:
        print(f"Failed to load image {img_path}: {e}")

def draw_start_screen(surface, btn_start, btn_kv, btn_settings):
    surface.fill(BG_COLOR)
    
    # Title
    t1 = header_font.render("THE GREAT SILENCE", True, ACCENT_COLOR)
    t2 = header_font.render("大静默", True, (255, 255, 255))
    
    mx = WINDOW_WIDTH // 2
    
    # Layout
    surface.blit(t1, (mx - t1.get_width() // 2, 220))
    surface.blit(t2, (mx - t2.get_width() // 2, 270))
    
    pygame.draw.line(surface, (50, 60, 70), (mx - 200, 310), (mx + 200, 310), 1)

    btn_start.draw(surface)
    btn_settings.draw(surface)
    btn_kv.draw(surface)

def draw_intro_screen(surface, text, color, alpha):
    surface.fill((0, 0, 0)) # 纯黑背景
    
    # 字体加载逻辑有点特殊，因为 alpha 需要 Surface 变换
    # 使用大一点的字体
    # 注意：为了性能，这里最好不要每帧重新加载 Font，为了简单我们直接用全局 header_font 如果够大的话
    # 这里我们还是临时创建一个大号字体
    try:
        f = pygame.font.Font(None, 60) # 使用默认字体，大号
    except:
        f = header_font
        
    # Render text to a temporary surface
    txt_surf = f.render(text, True, color)
    
    # Create an alpha-compatible surface
    alpha_surf = pygame.Surface(txt_surf.get_size(), pygame.SRCALPHA)
    
    # Blit text onto alpha surf
    alpha_surf.blit(txt_surf, (0, 0))
    
    # Apply alpha
    alpha_surf.set_alpha(alpha)
    
    # Center
    cx, cy = WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2
    surface.blit(alpha_surf, (cx - alpha_surf.get_width() // 2, cy - alpha_surf.get_height() // 2))

def draw_settings_screen(surface, btn_back, slider_vol):
    surface.fill(BG_COLOR)
    
    # Title
    t_surf = header_font.render("设置", True, ACCENT_COLOR)
    surface.blit(t_surf, (WINDOW_WIDTH // 2 - t_surf.get_width() // 2, 100))
    
    # Volume Control Area
    label_vol = font.render(f"音乐音量: {int(slider_vol.val * 100)}%", True, TEXT_COLOR)
    surface.blit(label_vol, (WINDOW_WIDTH // 2 - 150, 300))
    
    slider_vol.rect.centerx = WINDOW_WIDTH // 2
    slider_vol.rect.y = 350
    slider_vol.draw(surface)
    
    # Back button
    btn_back.draw(surface)

def draw_briefing_screen(surface, level, btn):
    surface.fill(BG_COLOR)
    
    # Title
    phase = font.render(level['phase'], True, ACCENT_COLOR)
    title = header_font.render(level['title'], True, (255, 255, 255))
    surface.blit(phase, (100, 100))
    surface.blit(title, (100, 130))
    pygame.draw.line(surface, ACCENT_COLOR, (100, 170), (1100, 170), 2)
    
    # Story
    y = 200
    if 'story_intro' in level:
        y = render_text_wrapped(surface, level['story_intro'], (100, y), 1000, font, TEXT_COLOR)
            
    # Mission Info
    y += 40
    pygame.draw.rect(surface, (20, 24, 30), (100, y, 1000, 200), border_radius=10)
    pygame.draw.rect(surface, (60, 60, 70), (100, y, 1000, 200), 1, border_radius=10)
    
    y_inner = y + 20
    if 'mission_info' in level:
        # Separate lines that might have "目标" for coloring, or just wrap all
        for line in level['mission_info'].split('\n'):
            col = (255, 200, 50) if "目标" in line else TEXT_COLOR
            y_inner = render_text_wrapped(surface, line, (130, y_inner), 940, font, col)
            y_inner += 5 # padding
            
    # Reward
    y_reward = y + 220
    if 'reward' in level:
        lbl = label_font.render("任务奖励:", True, SUCCESS_COLOR)
        val = font.render(level['reward'], True, (255, 255, 255))
        surface.blit(lbl, (100, y_reward))
        surface.blit(val, (100, y_reward + 25))

    btn.draw(surface)

def draw_letter_view(surface, level, btn):
    surface.fill((10, 10, 12)) 

    # Background scanlines
    for i in range(0, WINDOW_HEIGHT, 4):
        pygame.draw.line(surface, (15, 20, 25), (0, i), (WINDOW_WIDTH, i), 1)

    # Header
    h_surf = header_font.render("加密传输协议", True, (0, 200, 100))
    surface.blit(h_surf, (100, 80))

    # Meta Info
    meta_lines = [
        f"发送源:   {level.get('nodes', [{}])[0].get('name', 'UNKNOWN')}",
        f"接收端:   {level.get('nodes', [{}])[-1].get('name', 'UNKNOWN')}",
        f"日期:     2053-11-0{level.get('id', 0)}",
        f"协议:     {level.get('available_mods', ['BPSK'])[0]}",
        "------------------------------------------------------------"
    ]
    
    y = 140
    for line in meta_lines:
        s = font.render(line, True, (100, 255, 200)) # Green terminal style
        surface.blit(s, (100, y))
        y += 30

    # Letter Body (Typewriter effect)
    y += 20
    message = level.get('message', "")
    
    # Show chars based on global scroll index
    # We want a cursor effect
    chars_show = min(len(message), int(g_letter_scroll_idx))
    text_to_show = message[:chars_show]
    
    # Render with wrapping
    final_y = render_text_wrapped(surface, text_to_show, (100, y), 1000, font, (220, 220, 220))
    
    # Cursor
    if chars_show < len(message):
        # Calculate approximate cursor position (difficult with wrapped text function)
        # Simplified: just draw a blinking block at end of last line or separate
        if int(pygame.time.get_ticks() / 500) % 2 == 0:
            pass # Blink
    else:
        # Finished typing
        # Draw "END OF MESSAGE"
        end_surf = label_font.render("[信息结束]", True, (80, 80, 80))
        surface.blit(end_surf, (100, final_y + 20))
        
        # Show Button
        btn.draw(surface)

def draw_edu_showcase_screen(surface, btn_next):
    surface.fill(BG_COLOR)
    
    slides = g_edu_slides if g_edu_slides else []
    if not slides:
        btn_next.draw(surface)
        return

    idx = max(0, min(g_edu_slide_idx, len(slides) - 1))
    slide = slides[idx]
    
    # Title
    t_surf = header_font.render(slide['title'], True, ACCENT_COLOR)
    surface.blit(t_surf, (WINDOW_WIDTH//2 - t_surf.get_width()//2, 50))
    
    # Image
    slide_img_rel = slide['image']
    full_img_path = resource_path(slide_img_rel)
    
    try:
        if os.path.exists(full_img_path):
            img = pygame.image.load(full_img_path)
            iw, ih = img.get_size()
            scale = min(800/iw, 500/ih)
            if scale < 1:
                img = pygame.transform.scale(img, (int(iw*scale), int(ih*scale)))
            
            ix = WINDOW_WIDTH//2 - img.get_width()//2
            iy = WINDOW_HEIGHT//2 - img.get_height()//2 - 50
            surface.blit(img, (ix, iy))
            pygame.draw.rect(surface, (100, 100, 100), (ix-2, iy-2, img.get_width()+4, img.get_height()+4), 2)
    except Exception as e:
        print(f"Failed to draw edu image {full_img_path}: {e}")
        
    # Text
    y_txt = 650
    if 'text' in slide:
        render_text_wrapped(surface, slide['text'], (WINDOW_WIDTH//2, y_txt), 1000, font, TEXT_COLOR, align='center')
        
    # Page indicator
    p_txt = label_font.render(f"Page {idx+1}/{len(slides)}", True, (150, 150, 150))
    surface.blit(p_txt, (WINDOW_WIDTH - 150, WINDOW_HEIGHT - 80))

    btn_next.text = "开始任务" if idx >= len(slides) - 1 else "下一页"
    btn_next.draw(surface)

def draw_analysis_report(surface, result, close_btn):
    if not result or 'analysis_data' not in result:
        return
        
    data = result['analysis_data']
    
    # 1. Background Dimmer
    overlay = pygame.Surface((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.SRCALPHA)
    overlay.fill((5, 8, 15, 245)) # Darker, more solid
    surface.blit(overlay, (0, 0))
    
    # 2. Main Container
    cx, cy = WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2
    w, h = 1100, 700
    rect = pygame.Rect(cx - w//2, cy - h//2, w, h)
    
    pygame.draw.rect(surface, (15, 20, 28), rect, border_radius=15)
    pygame.draw.rect(surface, (50, 150, 255), rect, 2, border_radius=15)
    
    # Header
    title = header_font.render("回声重构报告", True, (255, 255, 255))
    surface.blit(title, (rect.x + 40, rect.y + 30))
    pygame.draw.line(surface, (60, 70, 80), (rect.x + 40, rect.y + 80), (rect.x + w - 40, rect.y + 80), 1)

    # --- Helper: Bit Grid Drawing ---
    def draw_bit_grid(surf, pos, bits, label, color_on=(0, 255, 200), color_off=(40, 45, 55), highlight_errors=None):
        surf.blit(label_font.render(label, True, (150, 150, 150)), pos)
        x_st, y_st = pos[0] + 120, pos[1] - 4
        slot_w, slot_h = 16, 22
        gap = 4
        
        if bits is None: return
        
        # Draw up to 24 bits
        for i, b in enumerate(bits[:24]):
            bx = x_st + i * (slot_w + gap)
            # Add extra gap every 8 bits
            bx += (i // 8) * 10
            
            r = pygame.Rect(bx, y_st, slot_w, slot_h)
            
            # Error Highlighting
            is_error = False
            if highlight_errors is not None and i < len(highlight_errors):
                if highlight_errors[i]: is_error = True
            
            bg_col = color_off
            if is_error:
                bg_col = (80, 20, 20)
                pygame.draw.rect(surf, (255, 50, 50), r.inflate(4, 4), width=1, border_radius=3)
            
            pygame.draw.rect(surf, bg_col, r, border_radius=3)
            
            txt_col = color_on if b == 1 else (100, 105, 115)
            if is_error: txt_col = (255, 100, 100)
            
            bit_t = label_font.render(str(int(b)), True, txt_col)
            surf.blit(bit_t, (r.centerx - bit_t.get_width()//2, r.centery - bit_t.get_height()//2))

    # --- Helper: Waveform Drawing ---
    def draw_waveform(surf, inner_rect, bits, mod_type, noise_snr=None):
        pygame.draw.rect(surf, (5, 5, 8), inner_rect, border_radius=5)
        pygame.draw.line(surf, (40, 40, 50), (inner_rect.left, inner_rect.centery), (inner_rect.right, inner_rect.centery))
        
        if bits is None or len(bits) == 0: return
        
        # We'll plot about 8 bits worth of wave
        display_bits = bits[:8]
        pts_per_bit = 40
        total_pts = len(display_bits) * pts_per_bit
        
        # For alignment visualization
        for i in range(len(display_bits) + 1):
            lx = inner_rect.left + (i / len(display_bits)) * inner_rect.width
            pygame.draw.line(surf, (25, 25, 30), (lx, inner_rect.top), (lx, inner_rect.bottom), 1)

        points = []
        for i in range(total_pts):
            bit_idx = i // pts_per_bit
            t_in_bit = (i % pts_per_bit) / pts_per_bit
            
            # Phase calculation
            if mod_type == "BPSK":
                phase = 0 if display_bits[bit_idx] == 0 else np.pi
            else: # QPSK or others (simplify to phase shift)
                phase = (bit_idx % 4) * (np.pi/2)
                
            val = np.sin(2 * np.pi * t_in_bit + phase)
            
            if noise_snr is not None:
                snr_linear = 10**(noise_snr/10.0)
                std = np.sqrt(1.0 / snr_linear)
                val += np.random.normal(0, std * 0.6)
            
            px = inner_rect.left + (i / total_pts) * inner_rect.width
            py = inner_rect.centery - val * (inner_rect.height * 0.4)
            points.append((px, py))
            
        if len(points) > 1:
            color = (0, 255, 255) if noise_snr is None else (255, 120, 50)
            pygame.draw.lines(surf, color, False, points, 2)

    # --- Step-by-Step Flow ---
    flow_x = rect.x + 60
    flow_y = rect.y + 110
    step_h = 85
    
    # 1. Word -> Bits
    sample_txt = result['tx_txt'].split()[0] if result['tx_txt'] else "DAT"
    surface.blit(font.render(f"Seq 1: 文本采样与位流转换 [{sample_txt}]", True, ACCENT_COLOR), (flow_x, flow_y))
    draw_bit_grid(surface, (flow_x + 30, flow_y + 35), data['raw_bits'], "原始比特:")
    
    # Arrow
    pygame.draw.line(surface, (60, 70, 80), (flow_x + 15, flow_y + 65), (flow_x + 15, flow_y + 85), 2)
    
    # 2. Encoding
    flow_y += step_h
    surface.blit(font.render(f"Seq 2: 纠错编码处理 ({data['code_type']})", True, ACCENT_COLOR), (flow_x, flow_y))
    draw_bit_grid(surface, (flow_x + 30, flow_y + 35), data['enc_bits'], "编码扩展:", (100, 255, 150))
    
    # Arrow
    pygame.draw.line(surface, (60, 70, 80), (flow_x + 15, flow_y + 65), (flow_x + 15, flow_y + 85), 2)
    
    # 3. Modulation
    flow_y += step_h
    surface.blit(font.render(f"Seq 3: 载波相位映射 ({data['mod_type']})", True, ACCENT_COLOR), (flow_x, flow_y))
    wave_rect_tx = pygame.Rect(flow_x + 30, flow_y + 30, 420, 60)
    draw_waveform(surface, wave_rect_tx, data['raw_bits'], data['mod_type'])
    # Draw bits aligned below waveform
    for i, b in enumerate(data['raw_bits'][:8]):
        bx = wave_rect_tx.left + (i + 0.5) * (wave_rect_tx.width / 8)
        col = (0, 255, 200) if b == 1 else (100, 105, 115)
        t = label_font.render(str(int(b)), True, col)
        surface.blit(t, (bx - t.get_width()//2, wave_rect_tx.bottom + 5))

    # 4. Noise
    flow_y += step_h + 35
    
    snr_label = f"(SNR: {result['final_snr']:.1f}dB)"
    surface.blit(font.render(f"Seq 4: 信道干扰影响 {snr_label}", True, ERROR_COLOR), (flow_x, flow_y))
    wave_rect_rx = pygame.Rect(flow_x + 30, flow_y + 30, 420, 60)
    draw_waveform(surface, wave_rect_rx, data['raw_bits'], data['mod_type'], noise_snr=result['final_snr'])

    # 5. Decode (with Error Highlighting)
    flow_y += step_h + 35
    surface.blit(font.render(f"Seq 5: 判决与纠错译码修复", True, ACCENT_COLOR), (flow_x, flow_y))
    
    # Fake error detection for visual feedback: compare dec_bits with raw_bits
    errors = []
    if data['raw_bits'] is not None and data['dec_bits'] is not None:
        min_len = min(len(data['raw_bits']), len(data['dec_bits']), 24)
        for i in range(min_len):
            # Since dec_bits is after correction, we can't easily show the "wrong" bit 
            # unless we captured demod_bits. Let's simulate a few "fixed" spots if not successful
            errors.append(data['raw_bits'][i] != data['dec_bits'][i])

    draw_bit_grid(surface, (flow_x + 30, flow_y + 35), data['dec_bits'], "最终输出:", (255, 215, 0), highlight_errors=errors if any(errors) else None)
    
    # 6. Final
    flow_y += step_h
    res_txt = result['rx_msg'].split()[0] if result['rx_msg'] else "???"
    surface.blit(font.render(f"Seq 6: 数据还原成果", True, SUCCESS_COLOR), (flow_x, flow_y))
    surface.blit(header_font.render(f"TEXT: [{res_txt}]", True, (255, 255, 255)), (flow_x + 30, flow_y + 30))

    # --- Right Side: Diagnostic Summary ---
    diag_rect = pygame.Rect(rect.x + 720, rect.y + 120, 330, 420)
    pygame.draw.rect(surface, (25, 30, 40), diag_rect, border_radius=10)
    pygame.draw.rect(surface, (60, 80, 110), diag_rect, 1, border_radius=10)
    surface.blit(font.render("未知建议 (Some Advisory)", True, (255, 215, 0)), (diag_rect.x + 20, diag_rect.y + 20))
    
    # Diagnostic content
    y_p = diag_rect.y + 60
    
    # NEW: Multi-hop summary
    if 'steps' in result and result['steps']:
        surface.blit(label_font.render("幻影回声跳跃 (Ghost Echo Hops):", True, (200, 200, 200)), (diag_rect.x + 20, y_p))
        y_p += 25
        for step in result['steps'][:5]: # Show up to 5 hops
            hop_color = (100, 255, 100) if step['snr'] > 5 else (255, 200, 0) if step['snr'] > -5 else (255, 100, 100)
            snr_val = step['snr']
            snr_str = f"{snr_val:.1f}dB" if snr_val > -900 else "BLOCKED"
            hop_txt = label_font.render(f"  {step['from']} -> {step['to']}: {snr_str}", True, hop_color)
            surface.blit(hop_txt, (diag_rect.x + 20, y_p))
            y_p += 20
        y_p += 10
        
    diag_msg = "本次传输状态: " + ("【优】" if result['success'] else "【警】") + "\n\n"
    if result['success']:
        diag_msg += f"当前的 {data['code_type']} 方案成功对抗了 {result['final_snr']:.1f}dB 的最终链路底噪。中转节点增益起到了关键作用。建议维持现状。"
    else:
        diag_msg += f"警告！{result['failure_reason']}\n\n观测到信源已在传输链条中途失真。建议检查阵列节点健康度或启用能量增益模组。"
    
    render_text_wrapped(surface, diag_msg, (diag_rect.x + 20, y_p), 290, label_font, TEXT_COLOR)

    close_btn.draw(surface)

def draw_tech_unlock_screen(surface, level, btn):
    surface.fill((10, 15, 20)) # Darker background
    if not level: return
    
    tech_info = level.get('tech_unlock_info') or {}
    
    # Title - Centered
    title = header_font.render(tech_info.get('title', 'Unknown Tech'), True, (100, 255, 100))
    mx = WINDOW_WIDTH // 2
    surface.blit(title, (mx - title.get_width()//2, 60))
    
    # Separator
    pygame.draw.line(surface, (50, 150, 50), (100, 100), (WINDOW_WIDTH - 100, 100), 2)
    
    y = 140
    
    # Image - Centered
    img_path = tech_info.get('image')
    if img_path:
        # Draw Image Centered
        draw_image_fit(surface, img_path, (mx, y + 150), (500, 300))
        y += 330 # Move down
    else:
        y += 20

    # Content Box - Centered & Widened
    box_width = WINDOW_WIDTH - 300
    box_x = (WINDOW_WIDTH - box_width) // 2
    
    # Calculate required height for text or use fixed height
    box_height = 400
    
    pygame.draw.rect(surface, (20, 25, 30), (box_x, y, box_width, box_height), border_radius=12)
    pygame.draw.rect(surface, (60, 80, 100), (box_x, y, box_width, box_height), 1, border_radius=12)

    # Text Content
    text_y = y + 30
    text_x = box_x + 40
    text_width = box_width - 80
    
    # Use larger font for description
    desc_font = header_font # Use header_font (size 32) instead of label_font/font
    
    full_text = ""
    if 'intro' in tech_info: full_text += tech_info['intro'] + "\n\n"
    if 'specs' in tech_info: full_text += tech_info['specs']
    
    render_text_wrapped(surface, full_text, (text_x, text_y), text_width, desc_font, (220, 220, 220))
    
    btn.draw(surface)

def draw_conclusion_screen(surface, level_id, btn):
    surface.fill((10, 15, 20)) # Darker background
    
    # Title
    title_text = "Part I 战报：关于 BPSK 与 QPSK 的观察"
    title_surf = header_font.render(title_text, True, ACCENT_COLOR) # Use game accent color
    mx = WINDOW_WIDTH // 2
    y_start = 60
    surface.blit(title_surf, (mx - title_surf.get_width()//2, y_start))
    
    # Separator
    pygame.draw.line(surface, (50, 150, 50), (100, y_start+40), (WINDOW_WIDTH - 100, y_start+40), 2)
    
    y = y_start + 60
    
    # Content Box - Centered & Widened
    box_width = WINDOW_WIDTH - 200
    box_x = (WINDOW_WIDTH - box_width) // 2
    box_height = 600
    
    pygame.draw.rect(surface, (20, 25, 30), (box_x, y, box_width, box_height), border_radius=12)
    pygame.draw.rect(surface, (60, 80, 100), (box_x, y, box_width, box_height), 1, border_radius=12)
    
    # Image - Left Side (60% width)
    img_path = "picture/compare_constellation.png"
    img_region_w = box_width * 0.65
    img_region_h = box_height - 40
    
    img_center_x = box_x + img_region_w / 2
    img_center_y = y + box_height / 2
    
    draw_image_fit(surface, img_path, (img_center_x, img_center_y), (img_region_w - 40, img_region_h))

    # Text Content - Right Side (Remaining width)
    text_x = box_x + img_region_w + 20
    text_y = y + 60
    text_width = box_width - img_region_w - 40
    
    desc_font = font # Use standard font
    
    # Paragraph 1
    para1 = "指挥官，您应该注意到了：虽然 QPSK 传输速度快了一倍，但在横跨大西洋的强噪声环境中，它的误码率急剧上升。"
    text_y = render_text_wrapped(surface, para1, (text_x, text_y), text_width, desc_font, (220, 220, 220))
    text_y += 30 
    
    # Paragraph 2
    para2 = "从右侧的星座图对比可以看出，QPSK 的四个信号点挤在一起，最小欧氏距离仅为 BPSK 的 0.7 倍，更容易被噪声挤出安全区。"
    text_y = render_text_wrapped(surface, para2, (text_x, text_y), text_width, desc_font, (220, 220, 220))
    text_y += 40
    
    # Conclusion
    para3 = "结论：在恶劣环境下，有时候“慢”就是“快”。BPSK 依然是可靠性之王。"
    conclusion_font = header_font # Bigger font for conclusion
    # Use simpler render since it's short and impactful
    # But wrap just in case
    render_text_wrapped(surface, para3, (text_x, text_y), text_width, conclusion_font, ACCENT_COLOR) # Use accent color for conclusion
    
    btn.draw(surface)

# --- Knowledge Base Logic ---
g_knowledge_ui_rects = []

def build_knowledge_db(level_mgr):
    global g_knowledge_list
    g_knowledge_list = []
    
    seen_titles = set()
    
    def add_item(title, text, image, unlocked=True, original_level_id=0):
        if title in seen_titles: return
        seen_titles.add(title)
        g_knowledge_list.append({
            'title': title,
            'text': text,
            'image': image,
            'unlocked': unlocked,
            'level_id': original_level_id
        })

    # Scan Levels
    for lvl in level_mgr.levels:
        # 1. Tutorial Slides
        if 'tutorial_slides' in lvl:
            for s in lvl['tutorial_slides']:
                add_item(s['title'], s['text'], s.get('image'), True, lvl.get('id', 0))
                
        # 2. Tech Unlock Info
        if 'tech_unlock_info' in lvl:
            t = lvl['tech_unlock_info']
            # Combine intro and specs for detail view
            full_text = t['intro'] + "\n\n" + t['specs']
            add_item(t['title'], full_text, t.get('image'), True, lvl.get('id', 0))

def draw_knowledge_menu(surface, btn_back):
    surface.fill(BG_COLOR)
    
    # Title
    t_surf = header_font.render("失落数据 (DATA LOGS)", True, ACCENT_COLOR)
    surface.blit(t_surf, (WINDOW_WIDTH//2 - t_surf.get_width()//2, 40))
    
    # Grid
    global g_knowledge_ui_rects
    g_knowledge_ui_rects = []
    
    start_x, start_y = 100, 120
    col_w, row_h = 350, 100
    gap_x, gap_y = 30, 20
    cols = 3
    
    for i, item in enumerate(g_knowledge_list):
        r = i // cols
        c = i % cols
        
        x = start_x + c * (col_w + gap_x)
        y = start_y + r * (row_h + gap_y)
        
        rect = pygame.Rect(x, y, col_w, row_h)
        g_knowledge_ui_rects.append((rect, item))
        
        # Draw Card
        hover = rect.collidepoint(pygame.mouse.get_pos())
        color = (40, 50, 60) if hover else (30, 35, 40)
        border = (100, 200, 255) if hover else (60, 70, 80)
        
        pygame.draw.rect(surface, color, rect, border_radius=8)
        pygame.draw.rect(surface, border, rect, 1, border_radius=8)
        
        # Text
        # Truncate title if too long
        title = item['title']
        if len(title) > 20: title = title[:18] + "..."
        
        t_card = font.render(title, True, (220, 220, 220))
        surface.blit(t_card, (x + 15, y + 35))
        
        # Icon placeholder (if image exists)
        if item.get('image'):
             pygame.draw.rect(surface, (50, 150, 150), (x + col_w - 40, y + 35, 20, 20), 1)

    btn_back.draw(surface)

def draw_knowledge_detail(surface, btn_back):
    surface.fill(BG_COLOR)
    
    item = g_current_knowledge_item
    if not item: 
        btn_back.draw(surface)
        return

    # Center Layout
    mx = WINDOW_WIDTH // 2
    
    # Title
    title = header_font.render(item['title'], True, ACCENT_COLOR)
    surface.blit(title, (mx - title.get_width()//2, 50))
    
    pygame.draw.line(surface, (50, 150, 50), (100, 100), (WINDOW_WIDTH-100, 100), 2)
    
    y = 130
    
    # Image - Centered
    if item.get('image'):
        # Try to fit image
        draw_image_fit(surface, item['image'], (mx, y + 150), (600, 300))
        y += 330
    else:
        y += 20
    
    # Text Content Box - Centered & Wide
    box_width = WINDOW_WIDTH - 300
    box_x = (WINDOW_WIDTH - box_width) // 2
    box_height = 400
    
    start_txt_y = y
    
    # Draw background for text
    pygame.draw.rect(surface, (20, 24, 30), (box_x, start_txt_y, box_width, box_height), border_radius=12)
    pygame.draw.rect(surface, (60, 65, 75), (box_x, start_txt_y, box_width, box_height), 1, border_radius=12)
    
    content = item['text']
    curr_y = start_txt_y + 30
    
    # Use larger font (header_font is usually ~32px, font is ~20px)
    # Let's use something in between or just header_font if it looks good
    # The user asked for "larger font"
    desc_font = header_font 
    
    # Use our wrapping function with centered box
    render_text_wrapped(surface, content, (box_x + 40, curr_y), box_width - 80, desc_font, TEXT_COLOR)

    btn_back.draw(surface)

# --- Hidden Level Logic ---
def generate_hidden_satellite_level():
    # 4 rows, 5 cols
    # Randomized status: 3 'good' total, max 1 per row. 
    # Row indices: 0, 1, 2, 3
    
    rows = 4
    cols = 5
    # good_total = 3 is ensured by picking 3 unique rows
    
    # Assign which rows get a good sat
    # Pick 3 unique rows from 4
    good_rows = np.random.choice(range(rows), 3, replace=False)
    
    # Grid structure
    nodes = []
    
    # 将中心 X 坐标设为地图区域的中心 (MAP_WIDTH // 2)
    # MAP_WIDTH 是 1020，所以中心约为 510
    map_center_x = MAP_WIDTH // 2
    
    # Source (Earth Connection)
    nodes.append({"name": "Earth Link", "pos": (map_center_x, 700), "type": "src", "status": "normal"})
    
    # Array Generation (Sector)
    # Center at (map_center_x, 850) (Below screen), radiating upwards
    center_x, center_y = map_center_x, 850
    base_radius = 200
    radius_step = 100
    angle_start = -np.pi * 0.8 # Left
    angle_end = -np.pi * 0.2 # Right
    angle_step = (angle_end - angle_start) / (cols - 1)
    
    for r in range(rows):
        # Determine if this row has a good sat
        has_good = r in good_rows
        good_col = -1
        if has_good:
            good_col = np.random.randint(0, cols)
            
        current_radius = base_radius + r * radius_step
        
        for c in range(cols):
            angle = angle_start + c * angle_step
            # Add some jitter
            jitter_a = np.random.uniform(-0.05, 0.05)
            jitter_r = np.random.uniform(-10, 10)
            
            px = center_x + (current_radius + jitter_r) * np.cos(angle + jitter_a)
            py = center_y + (current_radius + jitter_r) * np.sin(angle + jitter_a)
            
            # Status
            if c == good_col:
                status = "good" 
            else:
                status = "damaged"
                
            # 隐藏模式：不显示卫星好坏
            name = f"Sat-{r+1}-{c+1}"
                
            nodes.append({
                "name": name,
                "pos": (px, py),
                "type": "relay",
                "status": status
            })

    # Destination (Core)
    nodes.append({"name": "Array Core", "pos": (map_center_x, 100), "type": "dest", "status": "normal"})

    return {
        "id": "HIDDEN_SAT_ARRAY",
        "title": "遗落的矩阵",
        "phase": "Hidden: 尘封的记忆",
        "story_intro": "这是一个被遗忘的近地卫星阵列。\n由于电池组老化，阵列仅剩微弱的备用能源。\n一旦高能信号激发，供电平衡将被打破。",
        "mission_info": f"【系统限制】\n1. 能量瓶颈：你只有 {MAX_HIDDEN_ATTEMPTS} 次发射信号的机会，随后阵列将因过载关闭。\n2. 链路极不稳定：为了维持相位同步，中转站数量必须严格控制在 2-3 个节点。",
        "mission_text": f"目标：在 {MAX_HIDDEN_ATTEMPTS} 次尝试内，找出包含 2 或 3 个完好中转站的通信路径。",
        "message": "ANCIENT_ARRAY_ONLINE",
        "message_desc": "[矩阵重启]",
        "snr_mode": "distance", # Custom logic inside calc_snr overrides this partially
        "tx_power": 60, 
        "available_mods": ["BPSK", "QPSK"],
        "available_codes": ["Hamming(7,4)", "Polar"],
        "target_ber": 0.0, 
        "reward": "隐藏关卡完成：解锁信号增强器 (+6dB 全局被动)",
        "source_name": "Earth Link", "dest_name": "Array Core",
        "source_pos": (map_center_x, 700), "dest_pos": (map_center_x, 100),
        "nodes": nodes
    }

# Ghost Cube State
ghost_cube_timer = 0
ghost_cube_visible = False
ghost_cube_pos = (200, 650) # Near Earth in L10
ghost_cube_rect = pygame.Rect(0,0, 30, 30)

# --- 游戏平衡参数 ---
MAX_HIDDEN_ATTEMPTS = 5 # 隐藏关最大尝试次数
num_repaired_satellites = 0 # Track how many good sats found in Hidden Level

def update_ghost_cube(dt, current_level_id):
    global ghost_cube_timer, ghost_cube_visible, ghost_cube_pos
    
    # 仅在碎石带第一关 (Level 8) 出现，且访问过就不再出现
    if current_level_id != 8 or g_hidden_level_visited: 
        ghost_cube_visible = False
        return

    ghost_cube_timer += dt  # dt is ms
    
    cycle = 10000 # 10s
    show = 2000 # 2s
    
    mod_time = ghost_cube_timer % cycle
    
    # Circular Orbit around Earth (100, 700)
    # Radius ~80, Period ~5s (independent of visibility cycle to make it appear at diff spots)
    orbit_t = ghost_cube_timer * 0.001 # seconds
    center = (100, 700)
    radius = 80
    
    # Smooth orbital movement
    gx = center[0] + radius * np.cos(orbit_t)
    gy = center[1] + radius * np.sin(orbit_t)
    ghost_cube_pos = (gx, gy)
    
    if mod_time < show:
        ghost_cube_visible = True
        # Visual Glitch: Only flicker visibility/alpha, not position
        # Handled in draw (alpha) or here? 
        # Requirement: "Don't shake randomly". So we rely on smooth path.
    else:
        ghost_cube_visible = False
        
    ghost_cube_rect.topleft = ghost_cube_pos

def draw_ghost_cube(surface):
    if not ghost_cube_visible: return
    
    # Draw blurred square
    # Visual: Glitchy cyan box
    s = pygame.Surface((30, 30), pygame.SRCALPHA)
    s.fill((0, 255, 255, 100)) # Semi-transparent
    surface.blit(s, ghost_cube_pos)
    pygame.draw.rect(surface, (200, 255, 255), (*ghost_cube_pos, 30, 30), 1)

# --- APP ---
def main():
    global current_state, previous_state, g_letter_scroll_idx, g_intro_alpha, g_intro_timer
    
    current_mod = "BPSK"
    current_code = "None"
    
    # New: Polar Decoding Method Selection
    current_polar_method = "SC" # Default
    
    # New: Energy & Tech System
    energy = 3 # 能量有限
    has_laser_tech = False # 初始不可用，需解锁
    has_satellite_array_tech = False # 保持 False，等待玩家触发隐藏关
    laser_module_active = False # Toggle state
    
    sim_result = None
    level_complete = False
    show_analysis = False
    
    is_animating = False
    anim_progress = 0.0
    
    ui_mod_rects = []
    ui_code_rects = []
    
    # UI Rects for decoding methods
    ui_decoder_rects = []
    ui_tech_rects = []

    # New State Variables
    path_indices = [] # Stores indices of nodes in level['nodes']
    hidden_attempts = 0 # 隐藏关尝试次数
    
    # Dynamic Node Management
    # To prevent polluting the original levels.py data, we need to deep copy nodes when mission starts.
    import copy

    def cb_start_game():
        global current_state, g_intro_alpha, g_intro_timer
        # 进入开场动画
        current_state = STATE_INTRO_1
        g_intro_alpha = 0
        g_intro_timer = 0
        play_bgm(None) # 静音

    def cb_skip_intro():
        # 跳过开场直接进 BRIEFING
        global current_state, g_intro_alpha, g_intro_timer
        
        current_state = STATE_BRIEFING
    
        # Init first level logic
        level = level_mgr.get_current_level()
        if level:
            play_bgm(get_level_music(level.get('id', 0)))

    def start_level_play():
        nonlocal has_satellite_array_tech, hidden_attempts, sim_result, is_animating, path_indices, has_laser_tech
        global current_state, g_letter_scroll_idx

        sim_result = None
        is_animating = False
        path_indices = []
        hidden_attempts = 0 # 进入关卡重置尝试次数

        lvl = level_mgr.get_current_level()
        if not lvl:
            return

        try:
            lvl_id = int(lvl.get('id', 1))
        except:
            lvl_id = 999
            
        if lvl_id >= 6:
            has_laser_tech = True
            
        if 'nodes' in lvl:
            # Deep copy or ensure origin_pos is set. Since we modify nodes list, be careful.
            # Ideally reset nodes from backup if needed, but here we just patch.
            for node in lvl['nodes']:
                 if 'origin_pos' not in node:
                     node['origin_pos'] = node['pos']
            
            # Add dynamic satellite if needed
            if has_satellite_array_tech and isinstance(lvl_id, int):
                pos_to_add = None
                
                if lvl_id in [8, 9]:
                     pos_to_add = (100, 320) 
                elif lvl_id == 10:
                     pos_to_add = (140, 620)
                
                if pos_to_add:
                    exists = False
                    for n in lvl['nodes']:
                        if n.get('is_ancient_relay'): exists = True; break
                    
                    if not exists:
                        lvl['nodes'].append({
                            "name": "Sat-X (Ancient)",
                            "pos": pos_to_add,
                            "origin_pos": pos_to_add,
                            "type": "relay",
                            "is_ancient_relay": True
                        })
        
        # Check if we should show the letter view first
        if 'message' in lvl and lvl['message']:
            g_letter_scroll_idx = 0
            current_state = STATE_LETTER_VIEW
        else:
            current_state = STATE_PLAYING

    def start_edu_showcase():
        global current_state, g_edu_slides, g_edu_slide_idx
        lvl = level_mgr.get_current_level()
        if not lvl:
            return False
        slides = lvl.get('tutorial_slides')
        if slides and not lvl.get('tutorial_seen'):
            g_edu_slides = slides
            g_edu_slide_idx = 0
            lvl['tutorial_seen'] = True
            current_state = STATE_EDU_SHOWCASE
            return True
        return False

    def cb_start_mission():
        if start_edu_showcase():
            return
        start_level_play()

    def cb_next_edu_slide():
        global g_edu_slide_idx
        if not g_edu_slides:
            start_level_play()
            return
        g_edu_slide_idx += 1
        if g_edu_slide_idx >= len(g_edu_slides):
            start_level_play()
    
    def update_planet_dynamics(level):
        """Calculates new positions for nodes based on time."""
        if 'nodes' not in level: return
        
        t = pygame.time.get_ticks() / 1000.0 # Time in seconds
        
        # Level 6: Escape Velocity - Orbital Mechanics
        if level['id'] == 6:
            # Nodes: 
            # 0:Earth(Static), 1:Orbital(Orbit Earth), 2:DebrisA(Chaos), 
            # 3:L1(Lissajous), 4:LunarOrbit(Orbit Moon), 5:DebrisB(Chaos), 6:Luna(Static)
            
            # Earth (Index 0) - Static anchor
            earth_pos = level['nodes'][0]['origin_pos']
            
            # 1. Orbital Station (Index 1) - Low Earth Orbit (Elliptical)
            # Center: Earth, Radius: ~200px, Speed: Fast
            node = level['nodes'][1]
            bx, by = earth_pos
            angle = t * 0.5 
            node['pos'] = (bx + 200 * np.cos(angle), by + 150 * np.sin(angle))
            
            # 2. Debris Field Alpha (Index 2) - Chaotic Drift
            node = level['nodes'][2]
            ox, oy = node['origin_pos']
            node['pos'] = (ox + 20 * np.sin(t*1.2) + 10 * np.cos(t*2.5), 
                           oy + 20 * np.cos(t*1.5) + 5 * np.sin(t*3.0))

            # 3. Lagrange L1 (Index 3) - Lissajous (Figure-8)
            node = level['nodes'][3]
            ox, oy = node['origin_pos']
            # Figure-8 movement
            node['pos'] = (ox + 50 * np.sin(t * 0.4), 
                           oy + 30 * np.sin(t * 0.8))

            # Moon (Index 6) - Static anchor for local orbits
            moon_pos = level['nodes'][6]['origin_pos']

            # 4. Lunar Orbit (Index 4) - Retrograde Orbit around Moon
            node = level['nodes'][4]
            mx, my = moon_pos
            angle_m = -t * 0.3 # Negative for retrograde
            node['pos'] = (mx + 150 * np.cos(angle_m), my + 150 * np.sin(angle_m))

            # 5. Debris Field Beta (Index 5) - High Frequency Jitter
            node = level['nodes'][5]
            ox, oy = node['origin_pos']
            node['pos'] = (ox + 15 * np.sin(t*2.0 + 1), oy + 15 * np.cos(t*1.8))
        
        # Level 8: Asteroid Maze - Dynamic Obstacles
        elif level['id'] == 8:
            # 1. Update Relay Nodes (Orbiting Central Probe)
            # Center Probe (Index 3) - Static
            cx, cy = level['nodes'][3]['origin_pos']
            
            # Belt Outpost Alpha (Index 1)
            node = level['nodes'][1]
            angle1 = t * 0.2
            node['pos'] = (cx + 300 * np.cos(angle1), cy + 200 * np.sin(angle1))
            
            # Belt Outpost Beta (Index 2) - Opposite Phase
            node = level['nodes'][2]
            angle2 = t * 0.2 + np.pi
            node['pos'] = (cx + 300 * np.cos(angle2), cy + 200 * np.sin(angle2))
            
            # Comet 67P (Index 4) - Elliptical passing through
            node = level['nodes'][4]
            # Moves back and forth or large orbit
            ox, oy = node['origin_pos']
            node['pos'] = (ox + 50 * np.sin(t*0.5), oy + 100 * np.cos(t*0.5))

            # 2. Update Obstacles (Procedural Generation if needed)
            if 'obstacles' not in level:
                level['obstacles'] = []
                # Create a belt of asteroids (Reduced: Close to 8-10 pieces)
                # Using 2 rings instead of 3, with 4-5 per ring
                for r in [180, 260]:
                    count = 5 
                    for i in range(count):
                        theta_start = (2 * np.pi / count) * i
                        level['obstacles'].append({
                            # Dynamic props
                            'orbit_r': r,
                            'theta_start': theta_start,
                            'speed': (0.3 if r % 200 == 0 else -0.2) * (1.0 + np.random.rand()*0.2), 
                            'size': np.random.randint(15, 35),
                            'pos': [0,0] # Mutable
                        })
            
            # Update Obstacle positions
            for obs in level['obstacles']:
                # Orbit around Center Probe
                angle = obs['theta_start'] + obs['speed'] * t
                obs['pos'] = (
                    cx + obs['orbit_r'] * np.cos(angle),
                    cy + obs['orbit_r'] * np.sin(angle)
                )

        # Level 9: The Void (Kuiper Belt)
        elif level['id'] == 9:
            # Nodes: 0:Unified Array(Static), 1:Kuiper A, 2:Kuiper B, 3:Oort, 4:Deep Space, 5:The Void(Dest)
            
            # Center (Unified Array) - Static
            cx, cy = level['nodes'][0]['origin_pos']
            
            # Kuiper Belt Objects (Elliptical Orbits with Precession)
            # Node 1
            node = level['nodes'][1]
            a, b = 300, 150 # Ellipse radii
            angle = t * 0.15
            node['pos'] = (cx + a * np.cos(angle), cy + b * np.sin(angle))
            
            # Node 2 (Opposite phase, slightly different orbit)
            node = level['nodes'][2]
            a, b = 320, 180
            angle = t * 0.12 + np.pi
            node['pos'] = (cx + a * np.cos(angle), cy + b * np.sin(angle))
            
            # Oort Cloud (Node 3) - Very slow drift
            node = level['nodes'][3]
            ox, oy = node['origin_pos']
            node['pos'] = (ox + 50 * np.sin(t * 0.05), oy + 50 * np.cos(t * 0.04))
            
            # Deep Space Buoy (Node 4) - Floating
            node = level['nodes'][4]
            ox, oy = node['origin_pos']
            node['pos'] = (ox + 20 * np.sin(t * 0.2), oy + 20 * np.cos(t * 0.15))
            
            # Obstacles: Dense Ice Fields (Kuiper Debris)
            if 'obstacles' not in level:
                level['obstacles'] = []
                # Procedural generation of debris field (Reduced: 9 pieces)
                for i in range(9):
                    cx_obs = cx + np.random.randint(-100, 100) # Debris center variation
                    cy_obs = cy + np.random.randint(-50, 50)
                    level['obstacles'].append({
                        'pos': [0,0],
                        'orbit_r': np.random.randint(200, 500), # Wide band
                        'angle_start': np.random.rand() * 2 * np.pi,
                        'speed': (0.1 if i % 2 == 0 else -0.05) * (0.8 + np.random.rand()*0.4),
                        'size': np.random.randint(5, 12), # Small chunks
                         'center': (cx_obs, cy_obs)
                    })
            
            # Update Obstacles
            for obs in level['obstacles']:
                angle = obs['angle_start'] + obs['speed'] * t
                obs['pos'] = (
                    obs['center'][0] + obs['orbit_r'] * np.cos(angle),
                    obs['center'][1] + obs['orbit_r'] * np.sin(angle) * 0.6 # Flattened
                )
        
        # Level 10: Kunlun (Solar System)
        elif level['id'] == 10:
            # Nodes: 0:KUNLUN(Src), 1:Defense Sat, 2:Jovian Relay, 3:Mars, 4:Moon, 5:EARTH(Dest)
            
            # Node 5 (EARTH) - Static Anchor (Bottom Left)
            ex, ey = level['nodes'][5]['origin_pos']
            
            # Node 4 (Moon Base) - Orbits Earth
            node = level['nodes'][4]
            angle_m = t * 0.8
            node['pos'] = (ex + 100 * np.cos(angle_m), ey + 100 * np.sin(angle_m))
            
            # Node 3 (Mars Outpost) - Independent Orbit around Sun (simulated center)
            # Simulated Sun Center for visual context
            sun_x, sun_y = 600, 400
            
            node = level['nodes'][3]
            mx, my = node['origin_pos']
            # Mars moves in a wide arc
            node['pos'] = (mx + 30 * np.sin(t * 0.1), my + 10 * np.cos(t * 0.1)) 
            
            # Node 2 (Jovian Relay) - Jupiter Orbit System
            node = level['nodes'][2]
            jx, jy = node['origin_pos']
            node['pos'] = (jx + 20 * np.sin(t*0.05), jy + 20 * np.cos(t*0.05))
            
            # Node 0 (KUNLUN) - Far Out, Static position but internal rotation visual
            kx, ky = level['nodes'][0]['origin_pos']
            
            # Node 1 (Defense Sat Alpha) - Orbits KUNLUN
            node = level['nodes'][1]
            angle_k = t * 0.4
            node['pos'] = (kx + 120 * np.cos(angle_k), ky + 80 * np.sin(angle_k))
            
            # Obstacles: Solar Storms / Defense Swarms
            if 'obstacles' not in level:
                level['obstacles'] = []
                # 1. Swarm around Kunlun (Reduced: 4 pieces)
                for i in range(4):
                    level['obstacles'].append({
                        'type': 'swarm',
                        'center': (kx, ky),
                        'orbit_r': 180,
                        'angle_start': (2*np.pi/4)*i,
                        'speed': 0.5,
                        'size': 8,
                        'pos': [0,0]
                    })
                # 2. Solar Storm (Center Screen) (Reduced: 5 pieces)
                for i in range(5):
                    level['obstacles'].append({
                        'type': 'solar',
                        'center': (600, 400),
                        'orbit_r': np.random.randint(100, 350),
                        'angle_start': np.random.rand() * 2 * np.pi,
                        'speed': 0.1 * (1 if i%2==0 else -1),
                        'size': np.random.randint(15, 30),
                        'pos': [0,0]
                    })

            for obs in level['obstacles']:
                angle = obs['angle_start'] + obs['speed'] * t
                obs['pos'] = (
                    obs['center'][0] + obs['orbit_r'] * np.cos(angle),
                    obs['center'][1] + obs['orbit_r'] * np.sin(angle) * (0.8 if obs.get('type')=='solar' else 1.0)
                )

    def is_los_blocked(level, p1, p2):
        if 'obstacles' not in level: return False
        
        x1, y1 = p1
        x2, y2 = p2
        dx, dy = x2-x1, y2-y1
        line_len_sq = dx*dx + dy*dy
        if line_len_sq == 0: return False

        for obs in level['obstacles']:
            ox, oy = obs['pos']
            r = obs['size'] + 5 # Hitbox margin
            
            # Project obstacle center onto line segment
            # t = dot(P1->Obs, P1->P2) / |P1->P2|^2
            t = ((ox - x1) * dx + (oy - y1) * dy) / line_len_sq
            t = max(0, min(1, t))
            
            cx, cy = x1 + t*dx, y1 + t*dy
            dist_sq = (ox - cx)**2 + (oy - cy)**2
            
            if dist_sq < r*r:
                return True
        return False

    def cb_finish_tech_unlock():
        global current_state
        current_state = STATE_BRIEFING
    
    def toggle_laser():
        nonlocal laser_module_active, sim_result
        if has_laser_tech:
            laser_module_active = not laser_module_active
            sim_result = None # Clear result

    def set_mod(mod):
        nonlocal current_mod, sim_result, is_animating
        if current_mod != mod:
            current_mod = mod
            sim_result = None
            is_animating = False

    def set_code(code):
        nonlocal current_code, sim_result, is_animating
        if current_code != code:
            current_code = code
            sim_result = None
            is_animating = False
            
    def set_polar_method(method):
        nonlocal current_polar_method, sim_result
        if current_polar_method != method:
            current_polar_method = method
            sim_result = None

            sim_result = None
            is_animating = False

    def cb_run_sim():
        nonlocal is_animating, anim_progress, sim_result, energy, show_analysis, hidden_attempts
        # Allow retry even if level complete (for testing)
        if is_animating: return
        show_analysis = False
        
        level = level_mgr.get_current_level()
        
        # 隐藏关：尝试次数限制
        if level.get('id') == 'HIDDEN_SAT_ARRAY':
            if hidden_attempts >= MAX_HIDDEN_ATTEMPTS:
                sim_result = {
                    "success": False,
                    "ber": 1.0,
                    "rx_msg": "POWER DEPLETED",
                    "tx_txt": "ERROR",
                    "failure_reason": "核心能量耗尽。阵列已进入锁定状态，无法再次发射信号。你只能选择 EXIT 撤离。"
                }
                return
            hidden_attempts += 1 # 仅在发射时增加次数
        
        # Energy Check for Laser or Normal Transmission
        energy_cost = 1.0 if laser_module_active else 0.1
        
        if energy >= energy_cost:
            energy -= energy_cost
        else:
            sim_result = {
                "success": False,
                "ber": 1.0,
                "rx_msg": "ENERGY DEPLETED",
                "tx_txt": "ERROR",
                "rx_syms": [], # Fixed crash 'rx_syms'
                "failure_reason": f"能量不足 (需 {energy_cost} 能量)"
            }
            return

        
        # Check if path is valid for Node-based levels
        if 'nodes' in level:
            if not path_indices: return
            
            # Additional validation: Ensure we traverse from src to dest
            # path_indices is list of indices. 
            first_idx = path_indices[0]
            last_idx = path_indices[-1]
            if level['nodes'][first_idx]['type'] != 'src': return
            if level['nodes'][last_idx]['type'] != 'dest': return

            # 隐藏关：路径长度限制 (2-3 颗卫星 = 总长度 4-5)
            if level.get('id') == 'HIDDEN_SAT_ARRAY':
                 num_sats = len(path_indices) - 2
                 if num_sats < 2 or num_sats > 3:
                     sim_result = {
                        "success": False,
                        "ber": 1.0,
                        "rx_msg": "SYNC FAILED",
                        "tx_txt": "ERROR",
                        "rx_syms": [], # 确保 'rx_syms' 键存在以避免 UI 崩溃
                        "failure_reason": f"相位失步：当前链路包含 {num_sats} 颗卫星，不符合阵列要求的 2-3 颗规律。请右键清空并重新连线。"
                     }
                     # 用户未进行有效发射，返还一次尝试次数
                     if hidden_attempts > 0:
                         hidden_attempts -= 1 
                     return
                
        is_animating = True
        anim_progress = 0.0
        sim_result = None 

    def calculate_path_snr(p1, p2, tx_power, level=None, idx1=None, idx2=None):
        # 0. 检查视线遮挡 (Level 8, 9 特有逻辑)
        lvl_id = level.get('id') if level else None
        if lvl_id in [8, 9]:
             if is_los_blocked(level, p1, p2):
                 return -999.0

        # 1. 强制模式判定
        # 规则：Level 4, 5 采用 SNR 矩阵；Level 6-10 及隐藏关采用物理距离模型
        use_matrix = False
        if lvl_id in [4, 5] and 'snr_matrix' in level:
            use_matrix = True
        
        # 2. 如果是矩阵模式
        if use_matrix and idx1 is not None and idx2 is not None:
            try:
                val = level['snr_matrix'][idx1][idx2]
                if val is not None: return val
            except IndexError:
                pass
        
        # 3. 物理距离模型 (Level 6-10, 隐藏关, 或矩阵回退)
        dist = np.hypot(p1[0]-p2[0], p1[1]-p2[1])
        # Simple FSPL model scaled for screen pixels
        # FSPL(dB) = 20log10(d) + 20log10(f) + ... constant
        # Here we simplify: SNR = Ptx - PathLoss
        # PathLoss ~ 20log10(dist) for 2D propagation simulation
        if dist < 10: dist = 10 # Cap min distance to avoid Explosion
        
        path_loss = 20 * np.log10(dist)
        
        # User requested aggressive calibration for "Deep Space" feel
        # Target: Near(100px) ~ 4.5dB, Far(500px) ~ -9.5dB
        # ...
        system_loss = 15.5 
        
        # ** Hidden Level Logic: Satellite Array Health **
        node_gain = 0.0
        if level and level.get('id') == 'HIDDEN_SAT_ARRAY':
            # 1. 接收增益 (针对 idx2)
            if idx2 is not None and idx2 < len(level['nodes']):
                target_node = level['nodes'][idx2]
                status = target_node.get('status', 'normal')
                if status == 'damaged':
                    node_gain -= 1.9
                elif status == 'good':
                    node_gain += 3.1 # 接收端增益
            
            # 2. 发送增益 (针对 idx1)
            if idx1 is not None and idx1 < len(level['nodes']):
                source_node = level['nodes'][idx1]
                status = source_node.get('status', 'normal')
                if status == 'damaged':
                    node_gain -= 1.9 # 发送功率下降
                elif status == 'good':
                    node_gain += 3.1 # 发送功率增强
            
            # 特殊：如果是隐藏关，大幅降低基础损耗以体现“近地”优势
            system_loss = 5.0 
        
        # ** Ancient Sat Array Reward Logic **
        # Boost outgoing signals from the Ancient Relay / Sat-X (from Hidden Level)
        # Check source name directly or flag
        if level and idx1 is not None and idx1 < len(level['nodes']):
             src_node = level['nodes'][idx1]
             # Check for "Sat-X" name which we inject if repaired
             if src_node.get('name') == 'Sat-X':
                 # 根据排查出的卫星数给 Sat-X 的增益为 -4 + count * 5 dB
                 if 'num_repaired_satellites' in globals() and num_repaired_satellites > 0:
                     gain = -4.0 + num_repaired_satellites * 5.0
                     node_gain += gain
                 else:
                     node_gain += 0.0

        return tx_power - path_loss - system_loss + node_gain

    def finish_sim():
        nonlocal sim_result, level_complete
        level = level_mgr.get_current_level()
        
        raw_bits = dsp.str_to_bits(level['message'])
        
        # Determine Simulation Mode
        steps = []
        final_rx_bits = []
        rx_syms_last = None
        
        if 'nodes' in level:
            # Multi-hop processing
            current_bits = raw_bits
            
            # If no path selected (should be caught by cb_run_sim, but safety check)
            if not path_indices: return

            for i in range(len(path_indices) - 1):
                idx_a = path_indices[i]
                idx_b = path_indices[i+1]
                node_a = level['nodes'][idx_a]
                node_b = level['nodes'][idx_b]
                
                # Calculate Link SNR (Updated to use Matrix)
                snr = calculate_path_snr(node_a['pos'], node_b['pos'], level.get('tx_power', 60), level=level, idx1=idx_a, idx2=idx_b)

                # Update logic: Laser is no longer a "mod", it's an additive effect
                # Base modulation is used (e.g. BPSK/QPSK) 
                
                effective_snr = snr
                if laser_module_active:
                   # Laser Simulation: Massive gain at Physical Layer
                   lvl_id_safe = level.get('id', 0)
                   
                   # Early Stage (Orbit, Jupiter, Asteroid Belt) -> High Gain
                   if isinstance(lvl_id_safe, int) and lvl_id_safe in [6, 8]:
                       effective_snr += 4.0
                   elif isinstance(lvl_id_safe, int) and lvl_id_safe in [7]:
                       effective_snr += 9.0
                   elif isinstance(lvl_id_safe, int) and lvl_id_safe in [9]:
                       effective_snr += 5.0
                   # Late Stage (Kuiper Belt, Solar Flare) -> Degraded due to distance/dust
                   elif isinstance(lvl_id_safe, int) and lvl_id_safe > 8:
                       effective_snr += 2.0 
                   elif isinstance(lvl_id_safe, str):
                       effective_snr += 2.0 # Hidden levels also degraded
                   else:
                       effective_snr += 5.0 # Default for testing
                
                # Encode (Assumes same code for all hops for now)
                enc_bits = dsp.encode_data(current_bits, current_code)
                
                # Modulate
                tx_syms = dsp.modulate(enc_bits, current_mod) # current_mod should be BPSK/QPSK...
                
                # Channel Simulation
                rx_syms = dsp.channel_awgn(tx_syms, effective_snr)
                rx_syms_last = rx_syms
                
                # Demodulate & Decode logic...
                # ... (omitted for brevity)

                # Laser Post-Processing: "BER Reduction" capability
                # Even with high SNR, we simulate additional error correction or "precision"
                # If active, reduce errors in current hop by 90%
                
                # We need to run demod/decode FIRST to get tentative bits
                # ... (This logic is split in current code structure, let's consolidate)

                # Basic Demod
                demod_bits_hard = dsp.demodulate(rx_syms, current_mod)
                
                # Polar Soft-Input Logic
                soft_llr = None
                if current_code.startswith("Polar") and (current_mod == "BPSK" or current_mod == "QPSK"):
                     soft_llr = dsp.demodulate(rx_syms, current_mod, return_llr=True)

                if current_code.startswith("Polar"):
                    # FAIL FIX: Ensure we pass the ACTUAL current_code (e.g. "Polar(256,128)") 
                    # instead of just "Polar", so that dsp_engine knows N and K values.
                    # GENIE AIDED: Pass ground truth for CRC simulation
                    dec_bits = dsp.decode_data(demod_bits_hard, current_code, len(current_bits), soft_llr=soft_llr, decode_method=current_polar_method, ground_truth=current_bits)
                else:
                    dec_bits = dsp.decode_data(demod_bits_hard, current_code, len(current_bits))
                
                # Truncate
                eval_len = len(current_bits)
                hop_rx_bits = dec_bits[:eval_len] if len(dec_bits) >= eval_len else np.pad(dec_bits, (0, eval_len - len(dec_bits)), 'constant')
                
                # Calculate Step BER
                step_ber = dsp.calculate_ber(current_bits, hop_rx_bits)
                
                steps.append({
                    "from": node_a['name'], "to": node_b['name'],
                    "snr": effective_snr, "ber_hop": step_ber
                })
                
                # Chain for next hop
                current_bits = hop_rx_bits
            
            final_rx_bits = current_bits
            rx_syms = rx_syms_last
            last_snr = steps[-1]['snr'] if steps else 0
            
        else:
            # Legacy Single Hop (Level 1 etc)
            enc_bits = dsp.encode_data(raw_bits, current_code)
            tx_syms = dsp.modulate(enc_bits, current_mod)
            use_noise = level.get('id') != 1
            snr = level.get('snr_db', 10)
            
            if laser_module_active:
                lvl_id_safe = level.get('id', 0)
                if (isinstance(lvl_id_safe, int) and lvl_id_safe >= 8) or isinstance(lvl_id_safe, str):
                    snr += 2.0
                else:
                    snr += 20.0
                
            if use_noise:
                rx_syms = dsp.channel_awgn(tx_syms, snr)
            else:
                rx_syms = tx_syms
            
            demod_bits = dsp.demodulate(rx_syms, current_mod)
            dec_bits = dsp.decode_data(demod_bits, current_code, len(raw_bits))
            
            eval_len = len(raw_bits)
            final_rx_bits = dec_bits[:eval_len] if len(dec_bits) >= eval_len else np.pad(dec_bits, (0, eval_len - len(dec_bits)), 'constant')
            last_snr = snr
            rx_syms_last = rx_syms

        rx_msg = dsp.bits_to_str(final_rx_bits)
        ber = dsp.calculate_ber(raw_bits, final_rx_bits)
        
        # --- HACK: Level 10 Special Fix for Error Floor ---
        # 如果 BER 约为 0.0018 (即那个无法消除的 7 bits error)，且使用的是最强编码，则给 20% 机会直接通过
        if level.get('id') == 10 and current_code == "Polar(1024,512)":
            if 0.0017 < ber < 0.0019: # 0.0018 ± tolerance
                if np.random.random() < 0.2:
                     ber = 0.0
                     final_rx_bits = raw_bits # Force perfect match
                     rx_msg = dsp.bits_to_str(final_rx_bits) # Update message

        # Standard Pass Condition
        passed = (ber <= level['target_ber'] + 1e-6)
        if ber > 0.5: passed = False        

        # Special Rule for Hidden Level: Find Good Satellites (Dynamic Reward)
        if level.get('id') == "HIDDEN_SAT_ARRAY":
            good_sat_count = 0
            if 'nodes' in level and path_indices:
                for idx in path_indices:
                    node = level['nodes'][idx]
                    if node.get('status') == 'good':
                        good_sat_count += 1
            
            # 只要找到 1 颗就算通过，并更新“历史最高纪录”
            if good_sat_count >= 1:
                passed = True
                global num_repaired_satellites
                # 关键修复：取当前路径和历史纪录的最大值，防止由于最后一次连线差导致的覆盖
                num_repaired_satellites = max(num_repaired_satellites, good_sat_count)
                rx_msg = f"SUCCESS! {good_sat_count} Good Node(s) Identified."
            else:
                passed = False 
        
        if passed: 
            level_complete = True
            
            # Unlock Secret Reward
            if level.get('id') == "HIDDEN_SAT_ARRAY":
                 # Inject Sat-X into future levels (8, 9, 10)
                 # These are levels with IDs >= 8
                 for subsequent_level in level_mgr.levels:
                     lid = subsequent_level.get('id')
                     if isinstance(lid, int) and lid >= 8:
                         # Check if already added
                         has_x = any(n['name'] == 'Sat-X' for n in subsequent_level['nodes'])
                         if not has_x:
                             subsequent_level['nodes'].append({
                                 "name": "Sat-X", 
                                 "pos": (150, 650), # Near Earth (100, 700)
                                 "origin_pos": (150, 650),
                                 "type": "relay",
                                 "is_ancient_relay": True # Flag for logic
                             })
                 
                 nonlocal has_satellite_array_tech
                 has_satellite_array_tech = True
        
        # Determine failure reason
        failure_reason = ""
        if not passed:
            if laser_module_active and energy <= 0:
                failure_reason = "能源耗尽：激光模组因能源不足无法维持高增益链路。"
            elif any(s['snr'] <= -900 for s in steps):
                failure_reason = "视线阻断：信号路径被小行星或障碍物完全遮挡，请重新规划路径。"
            elif ber > level['target_ber']:
                failure_reason = "噪声过载：信道干扰过大，建议降低调制阶数或增加纠错编码强度。"
            else:
                failure_reason = "同步失败：接收端无法在当前信噪比下恢复有效比特流。"

        sim_result = {
            "level_id": level.get('id'),
            "rx_syms": rx_syms,
            "rx_msg": rx_msg,
            "ber": ber,
            "success": passed,
            "tx_txt": level['message'],
            "final_snr": last_snr,
            "steps": steps,
            "failure_reason": failure_reason,
            # Data for detailed analysis report
            "analysis_data": {
                "raw_bits": raw_bits[:64], # Sample first 64 bits
                "enc_bits": enc_bits[:64] if 'enc_bits' in locals() else None,
                "tx_syms": tx_syms[:32] if 'tx_syms' in locals() else None,
                "rx_syms": rx_syms[:32] if rx_syms is not None else None,
                "dec_bits": final_rx_bits[:64],
                "mod_type": current_mod,
                "code_type": current_code
            }
        }

        # 隐藏关：3次机会用完后自动结算退出
        if level.get('id') == 'HIDDEN_SAT_ARRAY' and hidden_attempts >= MAX_HIDDEN_ATTEMPTS:
            # 延迟一小会执行（或直接执行，因为分析界面还没弹出来）
            cb_exit_hidden()
        
    def cb_next_level():
        nonlocal level_complete, sim_result, current_mod, current_code, is_animating, path_indices, energy, has_laser_tech
        global current_state, g_tech_unlock_level
        
        # Award Energy (Up to 10 max)
        energy = min(10, energy + 2)

        # Get the level we JUST succeeded.
        completed_lvl = level_mgr.get_current_level()
        
        if level_complete:
            # Advance index.
            if level_mgr.next_level():
                level_complete = False
                sim_result = None
                is_animating = False
                path_indices = [] # Reset path
                
                # The NEW current level
                new_lvl = level_mgr.get_current_level()
                current_mod = new_lvl['available_mods'][0]
                current_code = new_lvl.get('available_codes', ["None"])[0]
                
                # Update Technology: Unlock Laser if we are at level 6 or higher
                if new_lvl['id'] >= 6:
                    has_laser_tech = True
                
                # Check directly in the COMPLETED level's data for tech unlock info.
                # Special Check: Level 2 Conclusion Screen
                if completed_lvl and completed_lvl.get('id') == 2:
                    current_state = STATE_CONCLUSION
                    g_conclusion_level = completed_lvl
                elif completed_lvl and 'tech_unlock_info' in completed_lvl:
                    current_state = STATE_TECH_UNLOCK
                    g_tech_unlock_level = completed_lvl
                else:
                    current_state = STATE_BRIEFING
            else:
                # 游戏通关：跳转到致谢屏幕 (方案 C)
                global credits_scroll_y
                credits_scroll_y = WINDOW_HEIGHT
                current_state = STATE_CREDITS
                level_mgr.current_level_idx = 0 # 重置，方便下次开始
                level_complete = False
                sim_result = None

    previous_state = STATE_START_SCREEN # Default logic

    def cb_open_knowledge_menu():
        global current_state, g_knowledge_list, previous_state
        # Lazy build
        if not g_knowledge_list:
            build_knowledge_db(level_mgr)
        previous_state = current_state
        current_state = STATE_KNOWLEDGE_MENU

    def cb_close_knowledge_menu():
        global current_state, previous_state
        # Return to previous state (Start Screen or Playing)
        if previous_state in [STATE_START_SCREEN, STATE_PLAYING, STATE_BRIEFING]:
             current_state = previous_state
        else:
             current_state = STATE_START_SCREEN

    def cb_back_to_start():
        global current_state
        current_state = STATE_START_SCREEN

    def cb_back_to_menu():
        global current_state
        current_state = STATE_KNOWLEDGE_MENU

    def cb_open_settings():
        global current_state
        current_state = STATE_SETTINGS

    def cb_back_from_settings():
        global current_state
        current_state = STATE_START_SCREEN

    def cb_restart_level():
        nonlocal path_indices, sim_result, level_complete, is_animating, energy, hidden_attempts
        # Reset State
        path_indices = []
        sim_result = None
        level_complete = False
        is_animating = False
        energy = 10 # Reset energy to full on restart
        
        # Check if hidden level
        current_lvl = level_mgr.get_current_level()
        if current_lvl and current_lvl.get('id') == 'HIDDEN_SAT_ARRAY':
            hidden_attempts = 0 # Reset attempts
            global num_repaired_satellites
            num_repaired_satellites = 0

    def cb_exit_hidden():
        global current_state, g_original_level, g_hidden_level_visited, num_repaired_satellites, g_tech_unlock_level
        nonlocal sim_result, level_complete, path_indices, is_animating
        if g_original_level:
            # 1. 直接使用 num_repaired_satellites（在 finish_sim 中已更新为最高纪录）
            # 不再根据当前 path_indices 重新计算，防止最后一次尝试失败导致归零
            final_count = num_repaired_satellites
            
            # 3. 标记为已访问
            g_hidden_level_visited = True
            
            # 4. 如果找出了良好卫星，将 Sat-X 注入到原始 Level 8 及后续关卡
            if final_count > 0:
                # 注入到原始 Level 8
                if not any(n['name'] == 'Sat-X' for n in g_original_level['nodes']):
                    g_original_level['nodes'].append({
                        "name": "Sat-X", 
                        "pos": (150, 650), 
                        "origin_pos": (150, 650),
                        "type": "relay",
                        "is_ancient_relay": True
                    })
                
                # 注入到后续所有关卡
                for lvl in level_mgr.levels:
                    lid = lvl.get('id')
                    if isinstance(lid, int) and lid > 8:
                        if not any(n['name'] == 'Sat-X' for n in lvl['nodes']):
                            lvl['nodes'].append({
                                "name": "Sat-X", 
                                "pos": (150, 650), 
                                "origin_pos": (150, 650),
                                "type": "relay",
                                "is_ancient_relay": True
                            })

            # 5. 构造结果汇报界面
            gain_val = -4.0 + final_count * 5.0 if final_count > 0 else 0
            g_tech_unlock_level = {
                'tech_unlock_info': {
                    'title': "阵列扫描任务：已完成 (Relay Array Survey)",
                    'intro': f"你已经成功退出了遗落的矩阵空间。根据你在探测期间解锁的最佳链路状态，我们对阵列中的卫星进行了信号分析。",
                    'specs': (f"【扫描结果】: 成功锁定 {final_count} 颗运行良好的古代卫星 (Ancient Relays)\n"
                              f"【Sat-X 状态】: 活跃 (Active)\n"
                              f"【技术收益】: 在后续远征中，Sat-X 将作为额外的链路节点出现，\n"
                              f"             并根据修复的卫星数量提供 +{gain_val:.1f} dB 的增益补偿。")
                }
            }
            current_state = STATE_TECH_UNLOCK

            # 6. 还原关卡
            level_mgr.levels[level_mgr.current_level_idx] = g_original_level
            g_original_level = None
            
            # 注意：不重置 num_repaired_satellites，它将持久化影响 Sat-X 增益
            
            # 重置模拟进度
            sim_result = None
            level_complete = False
            path_indices = []
            is_animating = False

    btn_start = Button(WINDOW_WIDTH//2 - 120, WINDOW_HEIGHT//2 + 50, 240, 60, "打破静默", cb_start_game, (0, 100, 150))
    # 稍微调整一下按钮宽度以容纳更长的文字
    btn_kv = Button(WINDOW_WIDTH//2 - 120, WINDOW_HEIGHT//2 + 130, 240, 60, "失落数据", cb_open_knowledge_menu, (100, 100, 120))
    btn_settings = Button(WINDOW_WIDTH//2 - 120, WINDOW_HEIGHT//2 + 210, 240, 60, "系统设置", cb_open_settings, (80, 80, 100))
    
    # Settings UI
    # Initialize slider with default volume 0.5 if not set, or get current
    current_vol = 0.5
    try:
        current_vol = pygame.mixer.music.get_volume()
    except:
        pass
    slider_vol = Slider(WINDOW_WIDTH // 2 - 150, 400, 300, 30, 0.0, 1.0, current_vol)
    btn_settings_back = Button(WINDOW_WIDTH // 2 - 120, 500, 240, 60, "保存并返回", cb_back_from_settings, (80, 80, 80))

    btn_mission = Button(WINDOW_WIDTH - 250, WINDOW_HEIGHT - 100, 200, 60, "建立链路", cb_start_mission, (0, 200, 100))
    btn_briefing_kv = Button(WINDOW_WIDTH - 480, WINDOW_HEIGHT - 100, 200, 60, "查阅数据", cb_open_knowledge_menu, (100, 100, 120))
    btn_next_edu = Button(WINDOW_WIDTH - 250, WINDOW_HEIGHT - 100, 200, 60, "下一页", cb_next_edu_slide, (0, 150, 220))
    btn_tech_ok = Button(WINDOW_WIDTH - 250, WINDOW_HEIGHT - 100, 200, 60, "确认接收", cb_finish_tech_unlock, (0, 150, 250))
    
    def cb_confirm_letter():
        global current_state
        current_state = STATE_PLAYING
        # No initial animation needed, user must connect nodes manually

    btn_letter_confirm = Button(WINDOW_WIDTH//2 - 100, WINDOW_HEIGHT - 100, 200, 60, "发送信号", cb_confirm_letter, (0, 150, 100))

    def cb_finish_conclusion():
        global current_state, g_conclusion_level, g_tech_unlock_level
        # Determine next state: Tech Unlock -> Briefing
        if g_conclusion_level and 'tech_unlock_info' in g_conclusion_level:
             current_state = STATE_TECH_UNLOCK
             g_tech_unlock_level = g_conclusion_level
        else:
             current_state = STATE_BRIEFING
        g_conclusion_level = None

    btn_conclusion_ok = Button(WINDOW_WIDTH - 250, WINDOW_HEIGHT - 100, 200, 60, "继续", cb_finish_conclusion, (0, 180, 255))

    # Back buttons
    btn_kv_back = Button(WINDOW_WIDTH - 220, WINDOW_HEIGHT - 80, 200, 50, "返回", cb_close_knowledge_menu, (80, 80, 80))
    btn_detail_back = Button(WINDOW_WIDTH - 220, WINDOW_HEIGHT - 80, 200, 50, "返回", cb_back_to_menu, (80, 80, 80))

    def cb_open_analysis():
        nonlocal show_analysis
        if sim_result: show_analysis = True

    def cb_close_analysis():
        nonlocal show_analysis
        show_analysis = False

    # HUD Layout Calculation
    hud_x_base = MAP_WIDTH + 20
    hud_width_eff = HUD_WIDTH - 40
    
    # Bottom-up allocation
    y_btn_tx = WINDOW_HEIGHT - 80 
    y_btn_kv = y_btn_tx - 60 
    
    # Analysis & Next occupy same slot dynamically or stack differently?
    # Original: Analysis was above KV.
    y_btn_analysis = y_btn_kv - 60
    
    btn_tx = Button(hud_x_base, y_btn_tx, hud_width_eff, 50, "广播序列 (-0.1 能源)", cb_run_sim, (40, 120, 60))
    btn_next = Button(hud_x_base, y_btn_tx, hud_width_eff, 50, "跳转扇区 >>", cb_next_level, (80, 80, 180))
    btn_knowledge = Button(hud_x_base, y_btn_kv, hud_width_eff, 50, "数据库", cb_open_knowledge_menu, (50, 60, 70))
    btn_analysis = Button(hud_x_base, y_btn_analysis, hud_width_eff, 50, "查看黑匣子", cb_open_analysis, (60, 60, 100))
    
    # Restart Button (Top Right of Map Area, not HUD?)
    # User wanted HUD optimized. Let's place Restart inside HUD but at top right corner of the HUD area
    # Or keep it where it was but adjust z-order/position to not overlap Constellation
    # Original: btn_restart_level = Button(WINDOW_WIDTH - 120, 70, 100, 30, ...)
    # This overlaps with the HUD header area (0-80). 
    # Let's move it to top-right of HUD (below header) or inside header.
    # Header is 0-80. 
    # HUD starts at MAP_WIDTH.
    btn_restart_level = Button(WINDOW_WIDTH - 110, 20, 90, 40, "回滚时间", cb_restart_level, (100, 100, 120))
    
    btn_close_report = Button(WINDOW_WIDTH // 2 - 100, WINDOW_HEIGHT // 2 + 300, 200, 50, "关闭显示", cb_close_analysis, (150, 50, 50))
    btn_exit_hidden = Button(20, 90, 100, 40, "退出", cb_exit_hidden, (150, 50, 50)) # Moved down to avoid overlap

    while True:
        level = level_mgr.get_current_level()
        # Music Controller logic based on current state and level
        if current_state == STATE_START_SCREEN:
            play_bgm("ofeliasdream.mp3")
        elif current_state in [STATE_BRIEFING, STATE_TECH_UNLOCK, STATE_PLAYING] and level:
            play_bgm(get_level_music(level.get('id', 0)))
        elif current_state == STATE_CREDITS:
            play_bgm("ofeliasdream.mp3")
        elif current_state in [STATE_INTRO_1, STATE_INTRO_2]:
            play_bgm(None) # 静音

        if not level and current_state not in [STATE_CREDITS, STATE_INTRO_1, STATE_INTRO_2]: break
        
        if level:
            if current_mod not in level['available_mods']: current_mod = level['available_mods'][0]
            if current_code not in level.get('available_codes', ["None"]): current_code = "None"

        if current_state == STATE_PLAYING and is_animating:
            anim_progress += 0.02
            if anim_progress >= 1.0:
                anim_progress = 1.0
                is_animating = False
                finish_sim()

        # Events
        events = pygame.event.get()
        for e in events:
            if e.type == pygame.QUIT: pygame.quit(); sys.exit()
            
            # --- Intro States Logic ---
            if current_state in [STATE_INTRO_1, STATE_INTRO_2]:
                if e.type in [pygame.KEYDOWN, pygame.MOUSEBUTTONDOWN]:
                    # 任意键跳过当前 Intro 阶段
                    if current_state == STATE_INTRO_1:
                        current_state = STATE_INTRO_2
                        g_intro_alpha = 0
                        g_intro_timer = 0
                    else:
                        cb_skip_intro()
            
            if current_state == STATE_START_SCREEN:
                btn_start.handle_event(e)
                btn_kv.handle_event(e)
                btn_settings.handle_event(e)
            
            elif current_state == STATE_SETTINGS:
                if slider_vol.handle_event(e):
                    # Volume changed
                    pygame.mixer.music.set_volume(slider_vol.val)
                btn_settings_back.handle_event(e)
            
            elif current_state == STATE_KNOWLEDGE_MENU:
                btn_kv_back.handle_event(e)
                if e.type == pygame.MOUSEBUTTONDOWN:
                    mx, my = e.pos
                    # Check cards
                    for rect, item in g_knowledge_ui_rects:
                        if rect.collidepoint((mx, my)):
                            global g_current_knowledge_item
                            g_current_knowledge_item = item
                            current_state = STATE_KNOWLEDGE_DETAIL
            
            elif current_state == STATE_KNOWLEDGE_DETAIL:
                btn_detail_back.handle_event(e)

            elif current_state == STATE_EDU_SHOWCASE:
                btn_next_edu.handle_event(e)

            elif current_state == STATE_BRIEFING:
                btn_mission.handle_event(e)
                btn_briefing_kv.handle_event(e)
                if level.get('id') == 'HIDDEN_SAT_ARRAY':
                    btn_exit_hidden.handle_event(e)
            
            elif current_state == STATE_TECH_UNLOCK:
                btn_tech_ok.handle_event(e)
            
            elif current_state == STATE_LETTER_VIEW:
                msg_len = len(level.get('message', ""))
                if e.type == pygame.MOUSEBUTTONDOWN:
                    if g_letter_scroll_idx < msg_len:
                        g_letter_scroll_idx = msg_len + 1 # Instant finish
                    else:
                        btn_letter_confirm.handle_event(e)
                else:
                    if g_letter_scroll_idx >= msg_len:
                         btn_letter_confirm.handle_event(e)

            elif current_state == STATE_CONCLUSION:
                btn_conclusion_ok.handle_event(e)
            
            elif current_state == STATE_CREDITS:
                if e.type == pygame.MOUSEBUTTONDOWN:
                    current_state = STATE_START_SCREEN

            elif current_state == STATE_PLAYING:
                # Common UI Events in Playing State
                btn_restart_level.handle_event(e)
                
                # DEBUG CHEAT: Press F6 to jump to Level 9
                if e.type == pygame.KEYDOWN and e.key == pygame.K_F6:
                     print("DEBUG: Jumping to Level 9")
                     for idx, lvl in enumerate(level_mgr.levels):
                        if lvl.get('id') == 10: # Target Level 8
                            level_mgr.current_level_idx = idx
                            # Reset State
                            path_indices = []
                            sim_result = None
                            level_complete = False
                            is_animating = False
                            # Unlock techs if jumping forward
                            has_laser_tech = True 
                            energy = 9999 # Infinite Energy
                            
                            # Reload
                            level = level_mgr.get_current_level()
                            if level:
                                current_mod = level['available_mods'][0]
                                current_code = level.get('available_codes', ["None"])[0]
                            current_state = STATE_BRIEFING
                            break

                if level.get('id') == 'HIDDEN_SAT_ARRAY':
                    btn_exit_hidden.handle_event(e)
                
                if show_analysis:
                    btn_close_report.handle_event(e)
                elif not is_animating:
                    # 如果关卡未完成，或者在隐藏关，才允许点击发射
                    if not level_complete or level.get('id') == 'HIDDEN_SAT_ARRAY':
                        btn_tx.handle_event(e)
                    
                    btn_knowledge.handle_event(e)
                    if sim_result:
                        btn_analysis.handle_event(e)

                    
                    if e.type == pygame.MOUSEBUTTONDOWN:
                        mx, my = e.pos
                        
                        # Node Selection Logic
                        if 'nodes' in level:
                            if e.button == 3: # Right click to clear
                                path_indices = []
                            elif e.button == 1:
                                # Check Ghost Cube Click
                                if ghost_cube_visible and ghost_cube_rect.collidepoint((mx, my)):
                                    # Trigger Hidden Level
                                    hidden_lvl = generate_hidden_satellite_level()
                                    
                                    # 保存原始关卡，支持点击 EXIT 退出
                                    global g_original_level
                                    g_original_level = level_mgr.levels[level_mgr.current_level_idx]
                                    
                                    level_mgr.levels[level_mgr.current_level_idx] = hidden_lvl
                                    current_state = STATE_BRIEFING
                                    path_indices = []
                                    is_animating = False
                                    level_complete = False
                                    sim_result = None
                                    continue # Skip other clicks

                                for idx, node in enumerate(level['nodes']):
                                    dist = np.hypot(mx - node['pos'][0], my - node['pos'][1])
                                    if dist < 20: # Hit radius
                                        # Path logic
                                        if not path_indices:
                                            if node['type'] == 'src': path_indices.append(idx)
                                        else:
                                            # Allow connecting to next node
                                            # Prevent immediate loop back to same node
                                            if idx != path_indices[-1]: 
                                                path_indices.append(idx)
                                        break

                        for rect, m in ui_mod_rects: 
                            if rect.collidepoint((mx, my)): set_mod(m)
                        for rect, c in ui_code_rects:
                            if rect.collidepoint((mx, my)): set_code(c)
                        # Decoder selection
                        for rect, d_method in ui_decoder_rects:
                             if rect.collidepoint((mx, my)): set_polar_method(d_method)
                        # Tech selection
                        for rect, tech in ui_tech_rects:
                             if rect.collidepoint((mx, my)):
                                 if tech == "Laser": toggle_laser()
                
                # 确保隐藏关内只能通过 EXIT 退出，屏蔽 NEXT MISSION 按钮交互
                if level_complete and level.get('id') != 'HIDDEN_SAT_ARRAY':
                    btn_next.handle_event(e)

        # Draw
        if current_state == STATE_START_SCREEN:
            draw_start_screen(screen, btn_start, btn_kv, btn_settings)
        
        elif current_state in [STATE_INTRO_1, STATE_INTRO_2]:
            g_intro_timer += 1
            # 简单的生命周期：Fade In (60帧) -> Hold (120帧) -> Fade Out (60帧)
            if g_intro_timer < 60:
                g_intro_alpha = int((g_intro_timer / 60) * 255)
            elif g_intro_timer < 180:
                g_intro_alpha = 255
            elif g_intro_timer < 240:
                g_intro_alpha = int(255 - ((g_intro_timer - 180) / 60) * 255)
            else:
                # 自动进入下一阶段
                if current_state == STATE_INTRO_1:
                    current_state = STATE_INTRO_2
                    g_intro_alpha = 0
                    g_intro_timer = 0
                else:
                    cb_skip_intro()
            
            txt = "HOPE IS A WAVEFORM" if current_state == STATE_INTRO_1 else "IS ANYONE OUT THERE?"
            col = (100, 200, 255) if current_state == STATE_INTRO_1 else (255, 255, 255)
            draw_intro_screen(screen, txt, col, max(0, min(255, g_intro_alpha)))

        elif current_state == STATE_SETTINGS:
            draw_settings_screen(screen, btn_settings_back, slider_vol)
        
        elif current_state == STATE_KNOWLEDGE_MENU:
            draw_knowledge_menu(screen, btn_kv_back)
        
        elif current_state == STATE_KNOWLEDGE_DETAIL:
            draw_knowledge_detail(screen, btn_detail_back)

        elif current_state == STATE_EDU_SHOWCASE:
            draw_edu_showcase_screen(screen, btn_next_edu)

        elif current_state == STATE_BRIEFING:
            draw_briefing_screen(screen, level, btn_mission)
            btn_briefing_kv.draw(screen)
            if level.get('id') == 'HIDDEN_SAT_ARRAY':
                btn_exit_hidden.draw(screen)
        elif current_state == STATE_TECH_UNLOCK:
            draw_tech_unlock_screen(screen, g_tech_unlock_level, btn_tech_ok)
        elif current_state == STATE_LETTER_VIEW:
            g_letter_scroll_idx += 2 # Speed of typing
            # 只有当显示完所有字时，才显示按钮
            # 在 draw_letter_view 内部判断
            draw_letter_view(screen, level, btn_letter_confirm)
        elif current_state == STATE_CONCLUSION:
            draw_conclusion_screen(screen, g_conclusion_level.get('id', 0) if g_conclusion_level else 0, btn_conclusion_ok)
        elif current_state == STATE_CREDITS:
            draw_credits_screen(screen)
        elif current_state == STATE_PLAYING:
            # Update Node Dynamics (Planets Orbiting)
            # Only move if not currently animating signal to keep visual consistent with calculation snapshot
            if not is_animating and not level_complete:
                update_planet_dynamics(level)
            
            ui_mod_rects.clear(); ui_code_rects.clear(); ui_tech_rects.clear()
            screen.fill(BG_COLOR)
            
            # Map Background
            pygame.draw.rect(screen, MAP_BG_COLOR, (0, 80, MAP_WIDTH, 800))
            
            # --- VFX: Starfield & Grid ---
            vfx_stars.update()
            vfx_stars.draw(screen)
            
            # Earth Background (Behind grid, front of stars)
            vfx_earth.draw(screen)

            vfx_grid.update()
            vfx_grid.draw(screen)
            
            # Radar Pings (Behind nodes but on top of map)
            vfx_radar.update()
            vfx_radar.draw(screen)
            
            # --- Ghost Cube (Hidden Trigger) ---
            if not is_animating and not level_complete:
                 update_ghost_cube(clock.get_time(), level.get('id', 0))
                 draw_ghost_cube(screen)

            # --- Dynamic Node Drawing ---
            if 'nodes' in level:
                 # Draw Connections (Pulsing Effect)
                if len(path_indices) > 0:
                    points = [level['nodes'][i]['pos'] for i in path_indices]
                    if len(points) > 1:
                        # 1. Base Line (Dimmer)
                        pygame.draw.lines(screen, (0, 80, 150), False, points, 3) # Darker base
                        
                        # 2. Moving Pulses
                        t = pygame.time.get_ticks() / 1000.0
                        pulse_speed = 200 # px per second
                        
                        for k in range(len(points) - 1):
                            p1 = np.array(points[k])
                            p2 = np.array(points[k+1])
                            vec = p2 - p1
                            dist = np.linalg.norm(vec)
                            
                            if dist < 1: continue
                            
                            dir_vec = vec / dist
                            
                            # Number of pulses on this segment based on distance
                            num_pulses = max(1, int(dist / 100))
                            
                            for i in range(num_pulses):
                                # Calculate progress (0.0 to 1.0) based on time and index
                                # Offset by segment index so it looks continuous-ish
                                segment_time_offset = k * 0.5 
                                progress = ((t * pulse_speed + i * (dist/num_pulses)) % dist) / dist
                                
                                cur_pos = p1 + vec * progress
                                
                                # Draw Pulse (Head is bright, tail is transparent-ish)
                                # Simple: Bright circle
                                pygame.draw.circle(screen, (100, 200, 255), cur_pos.astype(int), 3)
                                # Trail
                                trail_len = 15
                                trail_end = cur_pos - dir_vec * trail_len
                                pygame.draw.line(screen, (0, 150, 255), cur_pos.astype(int), trail_end.astype(int), 2)

                    # Draw rubber band line if not finished
                    last_node_idx = path_indices[-1]
                    last_node = level['nodes'][last_node_idx]
                    
                    if last_node['type'] != 'dest' and not is_animating:
                        mx, my = pygame.mouse.get_pos()
                        pygame.draw.line(screen, (100, 100, 100), last_node['pos'], (mx, my), 1)
                        
                        # Determine hovered node for Matrix SNR preview
                        hover_idx = None
                        for idx, node in enumerate(level['nodes']):
                            if np.hypot(mx - node['pos'][0], my - node['pos'][1]) < 20:
                                hover_idx = idx
                                break
                        
                        # 开启调试模式：显示实时预览 SNR
                        # 注意：隐藏关不显示 SNR，由玩家盲测
                        if level.get('id') != 'HIDDEN_SAT_ARRAY':
                            snr_temp = calculate_path_snr(last_node['pos'], (mx,my), level.get('tx_power', 60), level=level, idx1=last_node_idx, idx2=hover_idx)
                            
                            color_snr = (255, 200, 50) if hover_idx is not None else (150, 150, 150)
                            snr_surf = font.render(f"Link SNR: {snr_temp:.1f}dB", True, color_snr)
                            
                            screen.blit(snr_surf, (mx+10, my+10))

            # Draw Obstacles (Level 8, 9, 10)
            if 'obstacles' in level:
                for obs in level['obstacles']:
                    pos = obs['pos']
                    size = obs.get('size', 10)
                    
                    # Generate polygon vertices if not present
                    if 'poly_points' not in obs:
                         obs['poly_points'] = generate_asteroid_polygon(size)
                         obs['rotation'] = np.random.rand() * 2 * np.pi
                         obs['rot_speed'] = np.random.uniform(-0.02, 0.02)
                    
                    # Update rotation
                    obs['rotation'] += obs['rot_speed']
                    
                    if level['id'] == 8: # Asteroids
                        color = (80, 70, 60)
                        outline = (100, 90, 80)
                    elif level['id'] == 9: # Ice chunks (Kuiper)
                        color = (130, 180, 220, 200) # Light Blue
                        outline = (180, 220, 255)
                    elif level['id'] == 10: # Solar/Tech
                        if obs.get('type') == 'solar':
                            color = (255, 100, 50) # Orange
                            outline = (255, 200, 50)
                            # Pulse effect
                            size = size + np.sin(pygame.time.get_ticks()*0.01)*2
                            # Solar storms might just be circles still, or spiky polygons
                        else: # Swarm
                            color = (220, 40, 40) # Red
                            outline = (255, 100, 100)
                    else:
                        color = (100, 100, 100)
                        outline = (150, 150, 150)
                    
                    # Draw Poly
                    if level['id'] in [8, 9] or (level['id'] == 10 and obs.get('type') != 'solar'):
                        # Transform points
                        rot_points = []
                        cx, cy = pos
                        cos_a = np.cos(obs['rotation'])
                        sin_a = np.sin(obs['rotation'])
                        
                        for px, py in obs['poly_points']:
                            # Rotate then translate
                            rx = px * cos_a - py * sin_a
                            ry = px * sin_a + py * cos_a
                            rot_points.append((cx + rx, cy + ry))
                        
                        if len(rot_points) > 2:
                            pygame.draw.polygon(screen, color, rot_points)
                            pygame.draw.polygon(screen, outline, rot_points, 1)
                    else:
                         # Fallback for Solar Storms (Soft Circles)
                         pygame.draw.circle(screen, color, (int(pos[0]), int(pos[1])), int(size))
                         # Glow
                         pygame.draw.circle(screen, (color[0], color[1], color[2], 50), (int(pos[0]), int(pos[1])), int(size+4), 1)

            # Draw Nodes
            if 'nodes' in level:
                for i, node in enumerate(level['nodes']):
                    # Add random radar ping to nodes
                    vfx_radar.add(node['pos'][0], node['pos'][1])

                    color = (100, 255, 100) # Default
                    if node['type'] == 'src': color = (100, 255, 255)
                    elif node['type'] == 'dest': color = (255, 100, 100)
                    elif node['type'] == 'relay': color = (200, 200, 100)
                    
                    if i in path_indices:
                        pygame.draw.circle(screen, (255, 255, 255), node['pos'], 8) # Selected highlight
                        # Add constant ping for selected nodes
                        if np.random.random() < 0.1: vfx_radar.add(node['pos'][0], node['pos'][1])
                    
                    pygame.draw.circle(screen, color, node['pos'], 6)
                    
                    # Label
                    text = font.render(node['name'], True, (200, 200, 200))
                    rect = text.get_rect(center=(node['pos'][0], node['pos'][1] + 20))
                    pygame.draw.rect(screen, (0,0,0,150), rect.inflate(10,4), border_radius=3)
                    screen.blit(text, rect)
            else:
                # Legacy Drawing
                p0, p1, p2 = level['source_pos'], level['curve_control'], level['dest_pos']
                
                # Add Radar Pings for legacy nodes
                vfx_radar.add(p0[0], p0[1])
                vfx_radar.add(p2[0], p2[1])

                draw_map_connection(screen, p0, p1, p2, anim_progress, active=is_animating)
                draw_node(screen, p0, level['source_name'], False)
                draw_node(screen, p2, level['dest_name'], True)
            
            # 背景噪声视觉效果：除第一关外全部开启，或根据是否有节点判定
            if level.get('id') != 1:
                for _ in range(50):
                     pygame.draw.circle(screen, (40,50,60), (np.random.randint(0,MAP_WIDTH), np.random.randint(80,800)), 1)

            # Header Info
            pygame.draw.rect(screen, PANEL_COLOR, (0,0,WINDOW_WIDTH,80))
            screen.blit(header_font.render(f"{level['phase']} : {level['title']}", True, ACCENT_COLOR), (20,15))
            
            # Display appropriate SNR info
            if 'nodes' in level:
                snr_display = "Varies (Dist)"
                if sim_result and 'final_snr' in sim_result:
                    snr_display = f"Last Hop {sim_result['final_snr']:.1f}dB"
            else:
                snr_display = "No noise" if level.get('id') == 1 else f"{level['snr_db']}dB"
            
            screen.blit(font.render(f"Target BER < {level['target_ber']} | SNR: {snr_display}", True, (150,150,150)), (20,50))
            
            # Energy Display
            e_color = (100, 255, 255) if energy > 0 else (255, 50, 50)
            screen.blit(header_font.render(f"PWR: {energy}/10", True, e_color), (WINDOW_WIDTH - 220, 25))
            
            # Restart Button (Move to top right area, inside header or just below)
            # Coordinates updated in init
            if level.get('id') != 'HIDDEN_SAT_ARRAY':
                btn_restart_level.draw(screen)

            # Hidden Level Special UI: Attempts
            if level.get('id') == 'HIDDEN_SAT_ARRAY':
                attempts_left = MAX_HIDDEN_ATTEMPTS - hidden_attempts
                att_color = (255, 200, 50) if attempts_left > 0 else (255, 50, 50)
                screen.blit(font.render(f"Remaining Pings: {attempts_left}", True, att_color), (WINDOW_WIDTH - 220, 60))
            
            # HUD Background (Fills the right side)
            bx = MAP_WIDTH
            pygame.draw.rect(screen, (25, 25, 30), (bx, 0, HUD_WIDTH, WINDOW_HEIGHT))
            pygame.draw.line(screen, ACCENT_COLOR, (bx, 0), (bx, WINDOW_HEIGHT), 2)
            
            # --- 1. Constellation Monitor (Moved UP) ---
            cy_base = 40
            screen.blit(label_font.render("星图投影 (Star Chart)", True, ACCENT_COLOR), (bx + 15, cy_base))
            
            cy_box = cy_base + 20 # 105
            c_box_h = 160 # Reduced slightly
            pygame.draw.rect(screen, (0, 0, 0), (bx + 10, cy_box, HUD_WIDTH - 20, c_box_h), border_radius=5)
            pygame.draw.rect(screen, (60, 60, 70), (bx + 10, cy_box, HUD_WIDTH - 20, c_box_h), 1, border_radius=5)
            
            if sim_result:
                draw_constellation(screen, sim_result['rx_syms'], bx + HUD_WIDTH//2, cy_box + c_box_h//2, 60)
            else:
                cx_c, cy_c = bx + HUD_WIDTH//2, cy_box + c_box_h//2
                pygame.draw.line(screen,(40,40,40),(cx_c - 100, cy_c),(cx_c + 100, cy_c))
                pygame.draw.line(screen,(40,40,40),(cx_c, cy_c - 60),(cx_c, cy_c + 60))
                
            # --- 2. System Configuration ---
            y = cy_box + c_box_h + 20 # ~ 285
            screen.blit(label_font.render("阵列配置 (Array Config)", True, ACCENT_COLOR), (bx+10, y))
            y += 25
            
            # Mod Selection
            screen.blit(label_font.render("MOD", True, (150,150,150)), (bx+10, y+8))
            for i,mod in enumerate(level['available_mods']):
                btn_w = (HUD_WIDTH - 80) // 2
                r = pygame.Rect(bx+60+i*(btn_w+10), y, btn_w, 30)
                ui_mod_rects.append((r,mod))
                col = (0, 120, 200) if mod == current_mod else (50,50,60)
                pygame.draw.rect(screen, col, r, border_radius=4)
                if mod == current_mod: pygame.draw.rect(screen, (255,255,255), r, 1, border_radius=4)
                txt = label_font.render(mod, True, (255,255,255))
                screen.blit(txt, (r.centerx-txt.get_width()//2, r.centery-txt.get_height()//2))
            
            # Coding Selection
            y += 35
            screen.blit(label_font.render("CODE", True, (150,150,150)), (bx+10, y+8))
            codes = level.get('available_codes', ["None"])
            for i,code in enumerate(codes):
                # Spread out in grid if many
                cols = 2 if len(codes) > 2 else len(codes)
                row = i // cols
                col_idx = i % cols
                btn_w = (HUD_WIDTH - 80) // cols
                
                # If we have multiple lines, increment y for each new row
                current_y = y + row * 35
                
                r = pygame.Rect(bx+60+col_idx*(btn_w+5), current_y, btn_w, 30)
                ui_code_rects.append((r,code))
                col = (180,80,30) if code == current_code else (50,50,60)
                pygame.draw.rect(screen, col, r, border_radius=4)
                if code == current_code: pygame.draw.rect(screen, (255,255,255), r, 1, border_radius=4)
                txt = label_font.render(code, True, (255,255,255))
                screen.blit(txt, (r.centerx-txt.get_width()//2, r.centery-txt.get_height()//2))

            # Adjust y based on how many rows code buttons took
            num_rows_code = (len(codes) + 1) // 2 if len(codes) > 0 else 1
            y += num_rows_code * 35 + 10

            # System Status (Energy + Laser + Polar Decoder)
            screen.blit(label_font.render("生命维持/能源 (Life/Power Support)", True, ACCENT_COLOR), (bx+10, y))
            y += 25
            
            # Energy Display
            e_str = f"反应堆功率: {energy} / 10"
            screen.blit(font.render(e_str, True, (255, 200, 50)), (bx+20, y))
            # Energy Bar
            pygame.draw.rect(screen, (40, 40, 40), (bx+150, y+5, 200, 15))
            e_pct = max(0, min(1, energy / 10.0))
            pygame.draw.rect(screen, (255, 200, 50), (bx+150, y+5, int(200*e_pct), 15))
            
            y += 30

            # Decoder / Tech Row
            if current_code.startswith("Polar"):
                screen.blit(label_font.render("DEC:", True, (150,150,150)), (bx+10, y+5))
                methods = ["SC"]
                lvl_id = level.get('id', 1)
                if (isinstance(lvl_id, int) and lvl_id >= 6) or isinstance(lvl_id, str): methods.append("BP")
                if (isinstance(lvl_id, int) and lvl_id >= 7) or isinstance(lvl_id, str): methods.append("SCL")
                
                for j, method in enumerate(methods):
                    rect_d = pygame.Rect(bx + 60 + j*75, y, 70, 25)
                    ui_decoder_rects.append((rect_d, method))
                    col_d = (40, 120, 80) if current_polar_method == method else (40, 40, 50)
                    pygame.draw.rect(screen, col_d, rect_d, border_radius=4)
                    if current_polar_method == method: pygame.draw.rect(screen, (255, 255, 255), rect_d, 1, border_radius=4)
                    txt_d = label_font.render(method, True, (255,255,255))
                    screen.blit(txt_d, (rect_d.centerx - txt_d.get_width()//2, rect_d.centery - txt_d.get_height()//2))
                y += 40
            
            # Laser Tech (Unlock Check: Level >= 6)
            if isinstance(level.get('id', 0), int) and level.get('id', 0) >= 6:
                has_laser_tech = True
            
            if has_laser_tech:
                r_tech = pygame.Rect(bx+10, y, HUD_WIDTH-20, 30)
                ui_tech_rects.append((r_tech, "Laser"))
                col_t = (180, 30, 30) if laser_module_active else (60, 60, 65)
                pygame.draw.rect(screen, col_t, r_tech, border_radius=4)
                if laser_module_active: pygame.draw.rect(screen, (255, 100, 100), r_tech, 1, border_radius=4)
                status_str = "LASER MODULE: ACTIVE (-1.0 Energy)" if laser_module_active else "LASER MODULE: STANDBY"
                t_surf = label_font.render(status_str, True, (255,255,255))
                screen.blit(t_surf, (r_tech.centerx - t_surf.get_width()//2, r_tech.centery - t_surf.get_height()//2))
                y += 40

            y += 10 # Spacer

            # --- 3. Link Quality Monitor (Gauge) ---
            y_gauge = y + 5
            pygame.draw.rect(screen, (20,20,25), (bx+10, y_gauge, HUD_WIDTH-20, 110), border_radius=6)
            pygame.draw.rect(screen, (60,60,70), (bx+10, y_gauge, HUD_WIDTH-20, 110), 1, border_radius=6)
            screen.blit(label_font.render("回声解析 (Echo Analysis)", True, ACCENT_COLOR), (bx+20, y_gauge+10))
            
            # Target BER Marker
            target_ber = level['target_ber']
            curr_ber = sim_result['ber'] if sim_result else 1.0
            
            # Progress Bar for BER (Logarithmic scale since BER varies from 0.5 to 1e-6)
            def ber_to_width(b):
                if b <= 0: return 1.0
                return max(0, min(1.0, (np.log10(0.5) - np.log10(b)) / 6.0)) # Maps 0.5->0 to 5e-7->1

            bar_w = HUD_WIDTH - 60
            bar_rect = pygame.Rect(bx+30, y_gauge+40, bar_w, 20)
            pygame.draw.rect(screen, (40,40,45), bar_rect, border_radius=4)
            
            if sim_result:
                w = int(bar_w * ber_to_width(curr_ber))
                bar_col = SUCCESS_COLOR if curr_ber <= target_ber else ERROR_COLOR
                pygame.draw.rect(screen, bar_col, (bx+30, y_gauge+40, w, 20), border_radius=4)
            
            # Target tick
            target_x = bx+30 + int(bar_w * ber_to_width(target_ber))
            pygame.draw.line(screen, (255, 255, 255), (target_x, y_gauge+35), (target_x, y_gauge+65), 2)
            screen.blit(label_font.render("阈值", True, (255,255,255)), (target_x-15, y_gauge+67))
            
            # Numbers
            ber_str = f"{curr_ber:.4f}" if sim_result else "----"
            screen.blit(font.render(f"当前: {ber_str}", True, (220,220,220)), (bx+30, y_gauge+85))
            screen.blit(label_font.render(f"目标: <{target_ber}", True, (150,150,150)), (bx+HUD_WIDTH-120, y_gauge+88))

            # --- 4. Diagnostic Log / Signal History ---
            # Dynamic resizing based on available vertical space
            # Start below Link Quality
            y_diag = y_gauge + 120
            
            # Initialize log_lines
            log_lines = []
            if sim_result:
                if sim_result['success']:
                    log_lines = ["信号完整性：良好", "握手成功。正在同步星图...", "建议：当前配置已优化。"]
                else:
                    reason = sim_result.get('failure_reason', "链路建立失败。")
                    log_lines = [reason]
                    if "噪声" in reason: log_lines.append("建议：尝试更强的 Polar 码或 QPSK。")
                    elif "视线" in reason: log_lines.append("注意：传输路径被阻挡，检查中继。")
                    elif "能量" in reason: log_lines.append("注意：中继节点能量耗尽。")
            
            # Calculate max available height (leave space for buttons)
            # Buttons start at y = WINDOW_HEIGHT - 200 (Topmost Analysis button)
            # Let's give it a 20px padding
            y_buttons_top = WINDOW_HEIGHT - 200
            max_log_h = y_buttons_top - y_diag - 20
            
            log_box_h = max(100, max_log_h) 
            
            pygame.draw.rect(screen, (15,15,20), (bx+10, y_diag, HUD_WIDTH-20, log_box_h), border_radius=6)
            pygame.draw.rect(screen, (50,55,60), (bx+10, y_diag, HUD_WIDTH-20, log_box_h), 1, border_radius=6)
            
            # Using new name for the log area
            screen.blit(label_font.render("幻影回声追踪 (Ghost Echo Trace)", True, (255,200,50)), (bx+20, y_diag+10))
            
            diag_y = y_diag + 35
            
            # Use clipping to prevent overflow
            log_clip_rect = pygame.Rect(bx+12, diag_y, HUD_WIDTH-24, log_box_h - 40)
            screen.set_clip(log_clip_rect)
            
            if log_lines:
                for line in log_lines:
                    diag_y = render_text_wrapped(screen, f"> {line}", (bx+25, diag_y), HUD_WIDTH-50, label_font, (200,200,200))
                    diag_y += 2
                
                if sim_result and len(sim_result.get('steps', [])) > 0:
                    diag_y += 5
                    pygame.draw.line(screen, (60,60,70), (bx+20, diag_y), (bx+HUD_WIDTH-20, diag_y))
                    diag_y += 8
                    for step in sim_result['steps']:
                        quality = "OK" if step['ber_hop'] < 0.05 else "BAD"
                        col = SUCCESS_COLOR if quality == "OK" else ERROR_COLOR
                        txt = label_font.render(f"{step['from']}->{step['to']}: {step['snr']:.1f}dB ({quality})", True, col)
                        screen.blit(txt, (bx+25, diag_y))
                        diag_y += 18
            else:
                screen.blit(label_font.render("> 准备发射信号...", True, (100,100,100)), (bx+25, diag_y))
                screen.blit(label_font.render("> 检查视线 (LOS)...", True, (100,100,100)), (bx+25, diag_y+22))
            
            screen.set_clip(None)

            # Task Card (Repositioned to the Map Area)
            # 1. Pre-calculate height
            temp_y = 125
            for line in level['mission_text'].split('\n'):
                temp_y = render_text_wrapped(screen, line, (30, temp_y), 300, label_font, draw=False)
                temp_y += 2
            
            box_height = max(110, (temp_y - 90) + 10)
            c_rect = pygame.Rect(20, 90, 360, box_height)
            
            # Draw Background
            s = pygame.Surface((c_rect.width, c_rect.height), pygame.SRCALPHA)
            pygame.draw.rect(s, (20, 25, 35, 200), (0, 0, c_rect.width, c_rect.height), border_radius=8)
            screen.blit(s, (c_rect.x, c_rect.y))
            pygame.draw.rect(screen, (70, 90, 120), c_rect, 1, border_radius=8)
            
            screen.blit(label_font.render(f"任务简报 (BRIEFING)", True, (255, 200, 50)), (30, 100))
            y_off = 125
            for line in level['mission_text'].split('\n'):
                y_off = render_text_wrapped(screen, line, (30, y_off), 340, label_font, TEXT_COLOR)
                y_off += 2

            # Energy text update logic
            cost_disp = "1" if laser_module_active else "0.1"
            btn_tx.text = f"广播序列 (-{cost_disp} 能源)"
            
            if not is_animating: 
                # 如果关卡未完成，或者是隐藏关（隐藏关没有下一关按钮），显示发射按钮
                if not level_complete or level.get('id') == 'HIDDEN_SAT_ARRAY':
                    btn_tx.draw(screen)
                
            if not is_animating: btn_knowledge.draw(screen)
            
            # 如果关卡完成且不是隐藏关，显示下一关按钮（替代发射按钮）
            if level_complete and level.get('id') != 'HIDDEN_SAT_ARRAY': 
                btn_next.draw(screen)
            
            if sim_result and not is_animating: btn_analysis.draw(screen)
            
            # Restart Button (Always visible in Playing unless restricted)
            if level.get('id') != 'HIDDEN_SAT_ARRAY':
                btn_restart_level.draw(screen)
            
            if level.get('id') == 'HIDDEN_SAT_ARRAY':
                btn_exit_hidden.draw(screen)

            # Analysis Overlay
            if show_analysis:
                draw_analysis_report(screen, sim_result, btn_close_report)

        pygame.display.flip()
        clock.tick(60)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Game terminated by user.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
    finally:
        pygame.quit()
        if 'sys' in locals():
            sys.exit()
